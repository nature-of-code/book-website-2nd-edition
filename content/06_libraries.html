<section data-type="chapter">
<h1 id="true6-physics-libraries">true6. Physics Libraries</h1>
<blockquote data-type="epigraph">
  <p>“A library implies an act of faith/Which generations still in darkness hid/Sign in their night in witness of the dawn.”</p>
  <p>— Victor Hugo</p>
</blockquote>
<p>Before we move on to anything else, let’s revisit some of the things we’ve done in the first five chapters. We have:</p>
<ol>
  <li>Learned about concepts from the world of physics — What is a vector? What is a force? What is a wave?</li>
  <li>Understood the math and algorithms behind such concepts.</li>
  <li>Implemented the algorithms in p5.js with an object-oriented approach, culminating in building simulations of autonomous steering agents.</li>
</ol>
<p>These activities have yielded a set of motion simulation examples, allowing you to creatively define the physics of the worlds you build (whether realistic or fantastical). Of course, I’m not the first to try this. The world of computer graphics and programming is full of source code dedicated to physics simulations. Just try searching “open-source physics engine” and you could spend the rest of your day pouring over rich and complex code. And so I must ask the question: If a code library takes care of physics simulation, why should you bother learning how to write any of the algorithms yourself?</p>
<p>Here is where the philosophy behind this book comes into play. While many of the libraries out there give us physics (and super awesome advanced physics at that) for free, there are significant reasons for learning the fundamentals from scratch before diving into libraries. First, without an understanding of vectors, forces, and trigonometry, you’d likely be lost just reading the documentation of a library. Second, even though a library may take care of the math behind the scenes, it won’t necessarily simplify your code. As you’ll see in a moment, there can be a great deal of overhead in understanding how a library works and what it expects from you code-wise. Finally, as wonderful as a physics engine might be, if you look deep down into your hearts, it’s likely that you seek to create worlds and visualizations that stretch the limits of imagination. A library is great, but it provides a limited set of features. It’s important to know both when to live within limitations in the pursuit of a creative coding project and when those limits prove to be confining.</p>
<p>This chapter is dedicated to examining one popular open-source physics library for JavaScript—<a href="https://brm.io/matter-js/">matter.js</a> [and toxiclibs’ VerletPhysics engine?]. This is not to say that matter.js is the library I specifically recommend for any and all creative coding projects that merit the use of a robust physics engine. Matter.js, however, is one that integrates nicely with p5.js and will allow me to demonstrate the fundamental concepts behind physics engines and how they relate to and build upon the material from the first five chapters of this book.</p>
<h2 id="61-what-is-matterjs">6.1 What is Matter.js?</h2>
<p>When the first edition of this book was published, matter.js did not exist! The physics engine I used to demonstrate the examples at the time was (and likely still is) the most well known of them all: Box2D. Box2D began as a set of physics tutorials written in C++ by Erin Catto for the Game Developer’s Conference in 2006. Over the last fifteen plus years it has evolved into a rich and elaborate open-source physics engine. It’s been used for countless projects, most notably highly successful games such as the award-winning Crayon Physics and the runaway hit Angry Birds.</p>
<p>One of the key things about Box2D is that it is a true physics engine. Box2D knows nothing about computer graphics and the world of pixels. All of Box2D’s measurements and calculations are real-world measurements (meters, kilograms, seconds)—only its “world” is a two-dimensional plane with top, bottom, left, and right edges. You tell it things like: “The gravity of the world is 9.81 newtons per kilogram, and a circle with a radius of four meters and a mass of fifty kilograms is located ten meters above the world’s bottom.” Box2D will then tell you things like: “One second later, the rectangle is at five meters from the bottom; two seconds later, it is ten meters below,” etc. While this provides for an amazing and realistic physics engine, it also necessitates lots of complicated code in order to translate back and forth between the physics “world” (a key term in Box2D) and the world we want to draw on —the “pixel” world of Processing.</p>
<p>While this makes for an incredibly accurate and robust physics library (it’s also highly optimized and fast for c++ projects), it creates a tremendous burden for the coder. I will, as best I can, continue to maintain a set of Box2D compatible examples for this book (there are several JavaScript ports), but I believe the relative simplicity of working with a library that is native to JavaScript and uses pixels as the unit of measurement will make for a more intuitive and friendly bridge from my p5.js only examples.</p>
<p>Even so, anytime you add yet another JavaScript framework or library to a project, it introduces additional complexity and code. When is it worth it to have this additional overhead? If I just want to simulate a circle falling down a canvas gravity, do I really need to import an entire physics engine and learn its API for such an effect? I would say, the answer is no. You saw how to do this rather easily in the first chapter of this book. Let’s consider another scenario. What if I want to have a hundred of those circles falling? And what if those circles aren’t circles at all, but irregularly shaped polygons? And what if I want these polygons to bounce off each other in a realistic manner when they collide?</p><a data-type="indexterm" data-primary="collisions"></a><a data-type="indexterm" data-primary="physics" data-secondary="collisions"></a>
<p>You may have noticed that the first four chapters of this book, while covering motion and forces in detail, skipped over a rather important aspect of physics simulation—<em>collisions</em>. Let’s pretend for a moment that you aren’t reading a chapter about physics libraries and that I decided right now to cover how to handle collisions in a particle system. I’d have to introduce and cover two distinct algorithms that address these questions:</p>
<ol>
  <li>How do I determine if two shapes are colliding (i.e. intersecting)?</li>
  <li>How do I determine the shapes’ velocity after the collision?</li>
</ol>
<p>If you’re thinking about shapes like rectangles or circles, question #1 isn’t too tough. You’ve likely encountered this before. For example, two circles are intersecting if the distance between them is less than the sum of their radii.</p>
<figure>
  <img src="images/06_libraries/06_libraries_1.png" alt="Figure 5.1">
  <figcaption>Figure 5.1</figcaption>
</figure>
<p>OK. Now that you know how to determine if two circles are colliding, how about calculating their velocities after the collision? This is where I’m going to stop the discussion. Why, you ask? It’s not that understanding the math behind collisions isn’t important or valuable. (In fact, I’m including additional examples on the website related to collisions without a physics library.) The reason for stopping is that life is short (let this also be a reason for you to consider going outside and frolicking instead of programming altogether). We can’t expect to master every detail of physics simulation. And while I might enjoy this discussion for circles, it’s only going to lead to wanting to work with rectangles. And strangely shaped polygons. And curved surfaces. And swinging pendulums colliding with springy springs. And and and and and.</p>
<p>Working with collisions in a p5.js sketch while still having time to spend with friends and family—that’s the reason for this chapter. Erin Catto spent years developing solutions to these kinds of problems with Box2D and Liam has built a beautiful JavaScript library with matter.js so there’s no need to re-invent the proverbial wheel, at least for now.</p>
<p>In conclusion, if you find yourself describing an idea for a p5.js sketch and the word “collisions” comes up, then it’s likely time to learn a physics engine. (And over the course of this chapter, you might also encounter other words that lead down this path, such as “joint,” “hinge,” “pulley,” “motor,” etc.)</p>
<h2 id="62-working-with-matterjs-with-p5js">6.2 Working with Matter.js with p5.js</h2>
<p>There are a variety of ways to incorporate a JavaScript library into a project. For this book’s demonstrations, as you already quite aware, I’m using the official p5.js web editor for developing and sharing the code examples. The easiest way to add a library besides p5.js is to edit the <code>index.html</code> file that is part of every p5.js sketch.</p>
<p>This can be accomplished by opening the file navigation on the left hand side of the editor and selecting <code>index.html</code>.</p>
<figure>
  <img src="images/06_libraries/06_libraries_2.png" alt="">
  <figcaption></figcaption>
</figure>
<p>There, you’ll see in between the HTML tags <code>&#x3C;head></code> and <code>&#x3C;/head></code> a series of <code>&#x3C;script></code> tags. This is how JavaScript libraries are referenced in a p5.js sketch. It’s no different than including <code>sketch.js</code> or <code>particle.js</code> etc. in the page’s <code>&#x3C;body></code>. Only here, instead of keeping and editing a copy of the JavaScript code itself, we reference the library through a url of a “CDN.” A “CDN” is a “content delivery network” or, more plainly, a server hosting files. For JS libraries that are used across hundreds of thousands of web pages with millions upon millions of users accessing these pages, they need to be pretty good at their job of serving up these libraries.</p>
<p>In the page, you’ll see the CDN for p5.js.</p>
<pre class="codesplit" data-code-language="html">&#x3C;script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.1/p5.js">&#x3C;/script></pre>
<p>To use matter.js, just add right below p5, a reference to its CDN.</p>
<pre class="codesplit" data-code-language="html">&#x3C;script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.1/p5.js">&#x3C;/script>
&#x3C;script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js" integrity="sha512-5T245ZTH0m0RfONiFm2NF0zcYcmAuNzcGyPSQ18j8Bs5Pbfhp5HP1hosrR8XRt5M3kSRqzjNMYpm2+it/AUX/g==" crossorigin="anonymous" referrerpolicy="no-referrer">&#x3C;/script></pre>
<p>At the time of this writing, the most recent version of matter.js is <code>0.18.0</code> and that’s what you’ll see referenced in the above snippet. As matter.js updates and new versions are released, it’s often a good idea to upgrade, but by referencing the specific version that you know works with the code that you have written, you don’t have to worry about new features of the library breaking your existing code.</p>
<h2 id="63-matterjs-overview">6.3 Matter.js Overview</h2>
<p>Do not despair! I really am going to get to the code very soon, and in some ways I’ll blow the previous work out of the water. But before I’m ready to do that, it’s important to walk through the overall process of using matter.js (or any physics engine) in p5.js. Let’s begin by writing a pseudocode generalization of all of the examples in Chapters 1 through 5.</p>
<p><strong><em>SETUP:</em></strong></p>
<ol>
  <li>Create all the objects in the world.</li>
</ol>
<p><strong><em>DRAW:</em></strong></p>
<ol>
  <li>Calculate all the forces in the world.</li>
  <li>Apply all the forces to the objects (F = M * A).</li>
  <li>Update the positions of all the objects based on their acceleration.</li>
  <li>Draw all of the objects.</li>
</ol>
<p>Great. Let’s rewrite this pseudocode as it will appear in the matter.js examples.</p>
<p><strong><em>SETUP:</em></strong></p>
<ol>
  <li>Create all the objects in the world.</li>
</ol>
<p><strong><em>DRAW:</em></strong></p>
<ol>
  <li>Draw all of the objects.</li>
</ol>
<p>This, of course, is the fantasy of a physics engine. I’ve eliminated all of those painful steps of figuring out how the objects are moving according to velocity and acceleration. Matter is going to take care of this for us! The good news is that this does accurately reflect the overall process. Let’s imagine Matter as a magic box.</p>
<p>In <code>setup()</code>, I’m going to say to Matter: “Hello there. Here are all of the things I want in my world.” In <code>draw()</code>, I’m going to politely ask Matter: “Oh, hello again. If it’s not too much trouble, I’d like to draw all of those things in my world. Could you tell me where they are?”</p>
<p>The bad news: it’s not as simple as the above explanation would lead you to believe. Making the stuff that goes in the Matter.js world involves several steps related to how different kinds of shapes are built and configured. And it’s also necessary to learn to speak the language of Matter in terms of how all of the various forces and other parameters of the world are configured. Here are the core concepts</p>
<ol>
  <li><strong><em>Engine</em></strong>: The engine is the entity that manages the physics simulation itself, it holds onto the “world” of the simulation as well as various properties about how the world is updated over time.</li>
  <li><strong><em>Body</em></strong>: Serves as the primary element in the world. It has a position. It has a velocity. Sound familiar? The <code>Body</code> is essentially the class we’ve been writing on our own in our vectors and forces examples. It also has geometry to define its shape.</li>
  <li><strong><em>Composite</em></strong>: A composite is a container that allows for the creation of complex entities (made up of multiple bodies.) The world itself is an example a Composite, and every Body we create has be added to the world!</li>
  <li><strong><em>Constraint</em></strong>: Acts as a connection between two bodies.</li>
</ol>
<p>In the next four sections, I am going to walk through each of the above elements in detail, building several examples along the way. But first there is one other important element to briefly discuss.</p>
<p>5. <strong><em>Vector</em></strong>: Describes a vector in a matter.js world.</p>
<p>And so here we are, arriving with trepidation at an unfortunate truth in the world of using physics libraries. Any physics simulation is going to involve the concept of a vector. This is the good part. After all, you just spent several chapters familiarizing yourself with what it means to describe motion and forces with vectors. We don’t have to learn anything new conceptually.</p>
<p>Now for the part that makes the single tear fall from my eye: we don’t get to use <code>createVector()</code>. It’s nice that p5.js has <code>createVector()</code> for us, but anytime you use a physics library you will probably discover that the library includes its own vector implementation. This makes sense, after all; why should Matter.js be expected to know about <code>p5.Vector</code>objects? In most cases, the physics engine implements its vector class in a specific way so that it is especially compatible with the rest of the library’s code. So while you likely don’t have to learn anything new conceptually, you do have to get used to some new naming conventions and syntax. Let’s quickly demonstrate a few of the basics in <code>Matter.Vector</code> as compared to those in <code>p5.Vector</code>.</p>
<p>How do we create a Vector?</p>
<table>
  <thead>
    <tr>
      <th>p5.js</th>
      <th>Matter.js</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <pre class="codesplit" data-code-language="javascript">let v = createVector(1, -1);</pre>
      </td>
      <td>
        <pre class="codesplit" data-code-language="javascript">let v = Matter.Vector.create(1, -1);</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Let’s say we want to add two vectors together.</p>
<table>
  <thead>
    <tr>
      <th>p5.js</th>
      <th>Matter.js</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <pre class="codesplit" data-code-language="javascript">let a = createVector(1,-1);
let b = createVector(3, 4);
a.add(b);</pre>
      </td>
      <td>
        <pre class="codesplit" data-code-language="javascript">let a = Matter.Vector.create(1,-1);
let b = Matter.Vector.create(3, 4);
Matter.Vector.add(a, b, a);</pre>
      </td>
    </tr>
    <tr>
      <td>
        <pre class="codesplit" data-code-language="javascript">let a = createVector(1,-1);
let b = createVector(3, 4);
let c = p5.Vector.add(a, b);</pre>
      </td>
      <td>
        <pre class="codesplit" data-code-language="javascript">let a = Matter.Vector.create(1,-1);
let b = Matter.Vector.create(3, 4);
let c = Matter.Vector.add(a, b);</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>How about if we want to scale the vector with multiplication?</p>
<table>
  <thead>
    <tr>
      <th>p5.js</th>
      <th>Matter.js</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <pre class="codesplit" data-code-language="javascript">let v = createVector(1,-1);
v.mult(4);</pre>
      </td>
      <td>
        <pre class="codesplit" data-code-language="javascript">let v = Matter.Vector.create(1,-1);
v = Matter.Vector.mult(4);</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Magnitude and normalize?</p>
<table>
  <thead>
    <tr>
      <th>p5.js</th>
      <th>Matter.js</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <pre class="codesplit" data-code-language="javascript">let v = createVector(3,4);
let m = v.mag();
v.normalize();</pre>
      </td>
      <td>
        <pre class="codesplit" data-code-language="javascript">let v = Matter.Vector.create(3,4);
let m = Matter.Vector.magnitude(v);
v = Matter.Vector.normalise(v);</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>As you can see, the concepts are the same, but the function names and the arguments are different. First, everything is “name-spaced” under <code>Matter.Vector</code>. This is common for JavaScript libraries, p5.js is the unusual one in this regard. In p5 to draw a circle, one only need write <code>circle()</code> rather than <code>p5.circle()</code>. The <code>circle()</code> function lives in the “global” namespace. This, in my view, is one of the things that makes p5 special in terms of ease of use and beginner friendliness. However, it also means that for any code that you write with p5, you cannot use <code>circle</code> as a variable name. Name-spacing a library protects against these kinds of errors and conflicts from occurring and is why you see everything called with the <code>Matter</code> prefix.</p>
<p>In addition, unlike p5’s static and non-static versions of vector functions like <code>add()</code> and <code>mult()</code>, all vector functions in <code>Matter</code> are static. If you want to change a <code>Matter.Vector</code> while operating on it, you can add it as an optional argument (<code>Matter.Vector.add(a, b, a)</code>: adds <code>a</code> and <code>b</code> and places the result in <code>a</code>) or set an existing variable to the newly created vector object: (<code>v = Matter.Vector.mult(v, 2);</code>)</p>
<p>I’ll cover the basics of what you need to know for working with <code>Matter.Vector</code> in this chapter, but if you are looking for more, <a href="https://brm.io/matter-js/docs/classes/Vector.html">full documentation of can be found by on the Matter.js website</a>.</p>
<h2 id="64-matterjs-engine">6.4 Matter.js: Engine</h2>
<p>Many physics libraries include a “World” object to manage everything. The world is typically in charge of the coordinate space, keeping a list of all the bodies in the world, controlling time, and more. In Matter.js, the “world” is created inside of an <code>Engine</code> object, the main controller of your physics world and simulation.</p>
<pre class="codesplit" data-code-language="javascript">// An "alias" for Matter.js Engine class
const Engine = Matter.Engine;

// A reference to the matter physics engine
let engine;

function setup() {
  createCanvas(640, 360);
  // Create the Matter engine
  engine = Engine.create();
}</pre>
<p>Notice how the very first line of code creates a variable called <code>Engine</code> and sets it equal to <code>Matter.Engine</code>. Here, I am deciding to point the single keyword <code>Engine</code> to the <code>Engine</code> class namespaced inside Matter.js. I am making this decision because I know that I will not be using the word <code>Engine</code> for any other variables (nor does it conflict with something in p5.js) and want to be able to keep my code a little bit simpler. I’ll be doing this with <code>Vector</code>, <code>Bodies</code>, <code>Composite</code>, and more as I continue to build the examples. (But while the linked source code will always include all the alias’s, I won’t always include them in the book text itself.)</p>
<p>When you call <code>create()</code> on <code>Engine</code>, Matter.js will return a new physics engine and world with a default gravity (a vector— <code>(0,1)</code>—pointing down); however, you can alter it by accessing the <code>gravity</code> variable itself.</p>
<pre class="codesplit" data-code-language="javascript">  engine.gravity.x = 1;
  engine.gravity.y = 0;</pre>
<p>It’s worth noting that gravity doesn’t have to be fixed; you can adjust the gravity vector while your program is running. Gravity can be turned off by setting it to a (0,0) vector.</p>
<p>Once the world is initialized, we are ready to actually put stuff in the world—bodies!</p>
<h2 id="65-matterjs-bodies">6.5 Matter.js: Bodies</h2>
<p>A body is the primary element in the Matter world. It’s the equivalent to the <code>Mover</code> / <code>Particle</code> / <code>Vehicle</code> class I built in previous chapters—the thing that moves around the space and experiences forces. It can also be static (meaning fixed and not moving).</p>
<p>Matter.js bodies are created using “factory” methods found in <code>Matter.Bodies</code>. A “factory” method is a function that creates an object. While you probably more familiar with calling a constructor to create an object (e.g. <code>new Particle()</code>) you’ve seen factory methods before! For example, <code>createVector()</code> is a factory method for creating a <code>p5.Vector</code> object. Whether an object is created from a constructor or a factory method, is a matter of style and design choice by a library creator.</p>
<p>All of the factory methods can be found <a href="https://brm.io/matter-js/docs/classes/Bodies.html">in the </a><a href="https://brm.io/matter-js/docs/classes/Bodies.html"><code>Bodies</code></a><a href="https://brm.io/matter-js/docs/classes/Bodies.html"> documentation page</a>. Let’s start by looking at <code>rectangle()</code>.</p>
<pre class="codesplit" data-code-language="javascript">// Create a Matter.js Body with a rectangular shape
let box = Matter.Bodies.rectangle(x, y, w, h);</pre>
<p>Lucky us, the <code>rectangle()</code> function signature is exactly the same as p5.js’s <code>rect()</code> function! Only in this case, it’s not drawing a rectangle but instead is building the geometry for the physics engine itself.</p>
<p>The Body is now created and a reference is stored in the variable <code>box</code>. Bodies have many more properties that affect the body’s motion. There is <em>density</em>, which ultimately determines that body’s mass. <em>Friction</em> and <em>restitution</em> (“bounciness”) affect how the body interacts when it comes into contact with other bodies. For most cases, the defaults are sufficient, but Matter.js does allow you to specify these properties with an optional argument.</p>
<pre class="codesplit" data-code-language="javascript">// Specify additional properties of this Matter.js Body
let options = {
  friction: 0.5,    
  restitution: 0.8,
  density: 0.002  
}
let box = Matter.Bodies.rectangle(x, y, w, h, options);</pre>
<p>While the <code>options</code> variable is useful for configuring the</p>
<p>Finally, though not required, other initial conditions for the body, such as linear or angular velocity, can be called via methods static methods of the <code>Matter.Body</code> class.</p>
<pre class="codesplit" data-code-language="javascript">// Setting arbitrary initial linear and angular velocity
const v = Matter.Vector.create(2, 0);
Matter.Body.setVelocity(box, v);
Matter.Body.setAngularVelocity(box, 0.1);</pre>
<p>Creating a body and storing it in a variable is not the last step, however. Any body must explicitly be added to the “world” in order for it to be simulated with physics. Remember, the physics world I’ve created is a <code>Composite</code> object called <code>world</code> stored inside on the <code>engine</code> itself. The <code>box</code> can be added to that world with the static <code>add()</code> method.</p>
<pre class="codesplit" data-code-language="javascript">// Add the box object to the engine's world
Matter.Composite.add(engine.world, box);</pre>
<p>The above is easy to forget and a mistake that I’ve made on countless occasions. If you are ever wondering why one of your objects doesn’t appear or move along with the world’s physics, always check if you’ve actually added it to the world!</p>
<div data-type="exercise">
  <h3 id="exercise-61">Exercise 6.1</h3>
  <p>Knowing what you know about Matter.js so far, fill in the blank in the code below that demonstrates how to make a circular body.</p>
  <pre class="codesplit" data-code-language="javascript">// Specify additional properties of this Matter.js Body
let options = {
  friction: 0.5,    
  restitution: 0.8,
}
let ball = Matter.________.________(____, ____, ____, options);</pre>
</div>
<p></p>
<h2 id="66-matterjs-render">6.6 Matter.js: Render</h2>
<p>Once a body is added the world, Matter.js will always know it’s there, check it for collisions, move it appropriately according to the forces, etc. It’ll do all that for you without you having to lift a finger! The question therefore is how do you know where the box is at any given moment in order to draw it?</p>
<p>In the next section, I’m going to cover how to query Matter.js in order to render the world. How to do this is the primary reason for this chapter itself. This is your time to shine. You can be the designer of your world, and politely ask Matter.js to compute all the physics.</p>
<p>Matter.js, however, does include a fairly simple and straightforward <code>Render</code> class which is incredibly useful for quickly seeing and debugging the world you’ve designed. There are many ways you can customize the style of the debug drawing, but I find the defaults perfectly adequate for immediately being able to double-check that I’ve configured the world correctly.</p>
<p>The first step is to call <code>Matter.render.create()</code>. It expects an object with the desired settings for the renderer.</p>
<pre class="codesplit" data-code-language="javascript">
// Store the canvas in a variable
let canvas = createCanvas(640, 360);

// Configure the renderer
let params = {
  canvas: canvas.elt,
  engine: engine,
  options = { width: width, height: height }
}

// Create the renderer
let render = Matter.Render.create(params);</pre>
<p>Notice how in the code above, I am storing a reference to the p5 canvas in the variable <code>canvas</code>. This is necessary because I need to tell the renderer to draw into a specific canvas. Matter.js, however, does not know about p5.js, so the canvas it is assigned is the native HTML5 canvas, stored inside the <code>elt</code> property of a p5 canvas object. The engine is simply the <code>engine</code> previously created in 6.4. And Matter.js uses default canvas dimensions of 800x600 so if I prefer a different size, I’ll need to configure an <code>options</code> property with <code>width</code> and <code>height</code>.</p>
<p>Creating the renderer is not enough, however, I also need to tell Matter to run the renderer!</p>
<pre class="codesplit" data-code-language="javascript">// Run the renderer!
Matter.Render.run(render);</pre>
<p>There is one final and critical step, however. Physics engines must be told to “step” forward in time. Since we are using the debugging renderer, we can also use the debugging “runner” which will run the engine with a default framerate of 60 frames per second. The runner is also customizable but the details are not terribly important since the goal here is to move towards using p5.js’s <code>draw()</code> loop (coming in the next section.)</p>
<pre class="codesplit" data-code-language="javascript">// Run the engine!
Matter.Runner.run(engine);</pre>
<p>Here is all of the Matter.js code all together with an added <code>ground</code> object. Note the use of <code>{ isStatic: true }</code> in the creation of ground body to ensure that it remains in a fixed position.</p>
<div data-type="example">
  <h3 id="example-61-matterjs-default-render-and-runner">Example 6.1: Matter.js Default Render and Runner</h3>
  <figure>
    <div data-type="embed" data-p5-editor="https://editor.p5js.org/natureofcode/sketches/GXRa48IQO" data-example-path="examples/06_libraries/6_1_default_matter_js"></div>
    <figcaption></figcaption>
  </figure>
</div>
<pre class="codesplit" data-code-language="javascript">// {!5} Note the use of aliases for all of the Matter.js classes needed for this sketch.
const Engine = Matter.Engine;
const Bodies = Matter.Bodies;
const Composite = Matter.Composite;
const Body = Matter.Body;
const Vector = Matter.Vector;

function setup() {
  // Store a reference to the canvas
  let canvas = createCanvas(640, 360);

  // Create the physics engine
  let engine = Engine.create();
	
  // Create a renderer and assign to the p5 canvas
  const render = Matter.Render.create({
    canvas: canvas.elt,
    engine,
    options: { width, height },
  });
  Matter.Render.run(render);

  // Create a box with custom friction and restitution
  let options = {
    friction: 0.01,
    restitution: 0.75,
  };
  let box = Bodies.rectangle(100, 100, 50, 50, options);
  // Set initial velocity of box
  Body.setVelocity(box, Vector.create(5, 0));
  Body.setAngularVelocity(box, 0.1);
  // Add box to the world
  Composite.add(engine.world, box);

  // Create a static body for the ground
  let ground = Bodies.rectangle(width / 2, height - 5, width, 10, {
    isStatic: true,
  });
  Composite.add(engine.world, ground);

  // Create runner
  let runner = Matter.Runner.create();
  // Run the engine
  Matter.Runner.run(runner, engine);
}</pre>
<p>Notice how there is no <code>draw()</code> function and all of the variables are local to <code>setup()</code>! In this case, we are not making use of any of the capabilities of p5 (beyond injecting a canvas onto the page). This is exactly what I want to tackle next!</p>
<h2 id="67-matterjs-and-p5js">6.7 Matter.js and p5.js</h2>
<p>Now, as I demonstrated with the <code>Render</code> and <code>Runner</code> objects, Matter.js keeps a list of all the bodies that exist in the world and can handle drawing and animating them. (That list, incidentally, is stored in <code>engine.world.bodies</code>.) What I’m going to demonstrate here, however, is a technique for keeping your lists of bodies. Yes, this may be a bit redundant and I perhaps sacrifice a bit of efficiency. But I more than make up for that with ease of use. This methodology will allow me to program like I’m used to with p5.js, easily keep track of which bodies are which and render them appropriately. Let’s consider the structure of the following p5.js sketch:</p>
<figure>
  <img src="images/06_libraries/06_libraries_3.png" alt="">
  <figcaption></figcaption>
</figure>
<p>This looks like any ol’ p5.js sketch. We have the main <code>sketch.js</code> as well as <code>box.js</code>. The <code>box.js</code> file is where I might typically implement aclass to describe a <code>Box</code> object, a rectangular body in the world.</p>
<pre class="codesplit" data-code-language="javascript">class Box {
  constructor(x, y) {
    //{!2} A box has an x,y position and a width.
    this.x = x;
    this.y = y;
    this.w = 16;
  }

  show() {
    //{!5} The box is drawn as a square().
    rectMode(CENTER);
    fill(127);
    stroke(0);
    strokeWeight(2);
    square(this.x, this.y, this.w);
  }
}</pre>
<p>Let’s now write <code>sketch.js</code> and create new <code>Box</code> whenever the mouse is pressed and store all the <code>Box</code> objects in an array. (This is the same approach I took in the particle system examples from Chapter 4.)</p>
<div data-type="example">
  <h3 id="example-62-a-comfortable-and-cozy-p5-sketch-that-needs-a-little-matterjs">Example 6.2: A comfortable and cozy p5 sketch that needs a little Matter.js</h3>
  <figure>
    <div data-type="embed" data-p5-editor="https://editor.p5js.org/natureofcode/sketches/D26YvXr_S" data-example-path="examples/06_libraries/6_2_boxes_exercise"></div>
    <figcaption></figcaption>
  </figure>
</div>
<pre class="codesplit" data-code-language="javascript">//{!1} An array to store all Box objects
let boxes = [];

function setup() {
  createCanvas(640, 360);
}

function draw() {
  background(255);

  //{!3} When the mouse is pressed, add a new Box object.
  if (mouseIsPressed) {
    let b = new Box(mouseX, mouseY);
    boxes.push(b);
  }

  //{!3} Display all the Box objects.
  for (let i = 0; i &#x3C; boxes.length; i++) {
    boxes[i].show();
  }
}</pre>
<p>Now, here’s a challenge. Take the above example verbatim, but instead of drawing fixed boxes on the screen, draw boxes that experience physics (via Matter.js) as soon as they appear.</p>
<p>I’ll need two major steps to accomplish this goal.</p>
<h3 id="step-1-add-matterjs-to-the-p5-sketch-ie-setup-and-draw">Step 1: Add Matter.js to the p5 sketch (i.e. setup() and draw()).</h3>
<p>This part is not too tough. I demonstrated all the elements needed in the discussion of building a Matter.js world in the previous sections. (And don’t forget, in order for this to work, make sure the library is imported in <code>index.html</code>!)</p>
<p>All I need to do is add aliases for the Matter classes I need and create an <code>engine</code> in <code>setup()</code>.</p>
<pre class="codesplit" data-code-language="javascript">//{!3} Aliases for Engine, Bodies, and Composite
const Engine = Matter.Engine;
const Bodies = Matter.Bodies;
const Composite = Matter.Composite;

//{!1} The engine is now a global variables!
let engine;

void setup() {
  //{!1} Create the engine.
  engine = Engine.create();
}</pre>
<p>Then in <code>draw()</code>, we need to make sure we call one very important function: <code>Engine.update()</code>. This is instead of using the automatic <code>Matter.Runner</code>. After all, we already have a runner, the p5.js <code>draw()</code> loop! If you forget this function, nothing will happen! <code>Engine.update()</code> advances the physics world a step forward in time. Internally, Matter.js sweeps through and looks at all of the Bodies and figures out what to do with them. Just calling <code>step()</code> on its own moves the world forward with default settings; however, as with <code>Matter.Render</code> it is customizable (<a href="https://brm.io/matter-js/docs/classes/Engine.html#method_update">and documented in the Matter.js reference</a>).</p>
<pre class="codesplit" data-code-language="javascript">function draw() {
  //{!1} Step the engine forward in time!
  Engine.update(engine);
}</pre>
<h3 id="step-2-link-every-box-object-with-a-matterjs-body">Step 2: Link every Box object with a Matter.js Body.</h3>
<p>As of this moment, the <code>Box</code> class includes variables for position and width. What I now want to say is:</p>
<p>“I hereby relinquish the command of this object’s position to Matter.js. I no longer need to keep track of anything related to position, velocity, and acceleration. Instead, I only need to keep track of a <code>Body</code> and have faith that Matter.js will do the rest.”</p>
<pre class="codesplit" data-code-language="javascript">class Box {
  constructor(x, y) {
    this.w = 16;
    // {!1} Instead of any of the usual variables, a reference a body is stored.
    this.body = Bodies.rectangle(x, y, this.w, this.w);
    // {!} Can't forget to add it to the world!
    Composite.add(engine.world, this.body);
  }</pre>
<p>We don’t need <em>(x,y)</em> anymore since, as we’ll see, the body itself will keep track of its position. The body technically could also keep track of the width and height for us, but since Matter.js isn’t going to do anything to alter those values over the life of the <code>Box</code> object, it’s a bit more convenient to store in its own property until it’s time to draw the <code>Box</code>.</p>
<p>OK, almost there. Before I introduced Matter, it was easy to draw the <code>Box</code>. The object’s position was stored in variables <code>x</code> and <code>y</code>.</p>
<pre class="codesplit" data-code-language="javascript">  // Drawing the object using square()
  show() {
    rectMode(CENTER);
    fill(127);
    stroke(0);
    strokeWeight(2);
    square(this.x, this.y, this.w);
  }</pre>
<p>But now Matter manages the object’s motion, I can no longer use my own variables to position and draw the shape. Not to fear! The <code>Box</code> object has a reference to the body associated with it. So all I need to do is politely ask the body, “Pardon me, where are you located?”</p>
<pre class="codesplit" data-code-language="javascript">let pos = this.body.position;</pre>
<p>Just knowing the position of a body isn’t enough; I also need to know its angle of rotation.</p>
<pre class="codesplit" data-code-language="javascript">let a = this.body.angle;</pre>
<p>Once I have the position and angle, I can render the object using <code>translate()</code> and <code>rotate()</code>.</p>
<pre class="codesplit" data-code-language="javascript">  show() {
    //{!2} I need the Body’s position and angle.
    let pos = this.body.position;
    let a = this.body.angle;

    rectMode(CENTER);
    fill(127);
    stroke(0);
    strokeWeight(2);
    push();
    //{!2} Using the position and angle to translate and rotate the square
    translate(pos.x, pos.y);
    rotate(a);
    square(0, 0, this.w);
    pop();
  }</pre>
<p>It’s important to note here that if you follow the technique demonstrated in Chapter 4 to remove objects (based on a “lifespan” or if they move outside the boundaries of the canvas), you also must explicitly remove the body associated with your object from the Matter.js world. This can be done with a <code>removeBody()</code> method.</p>
<pre class="codesplit" data-code-language="javascript">  // This function removes a body from the Matter.js world.
  void removeBody() {
    Composite.remove(engine.world, this.body);
  }</pre>
<div data-type="exercise">
  <h3 id="exercise-62">Exercise 6.2</h3>
  <figure>
    <div data-type="embed" data-p5-editor="https://editor.p5js.org/natureofcode/sketches/oIZSHFXXk" data-example-path="examples/06_libraries/6_2_boxes_solved"><img src="examples/06_libraries/6_2_boxes_solved/screenshot.png"></div>
    <figcaption>Drag the mouse to add boxes.</figcaption>
  </figure>
  <p>Find the example sketch called “<a href="https://editor.p5js.org/natureofcode/sketches/D26YvXr_S">6.2 Boxes Exercise</a>.” Using the methodology outlined in this chapter, add the code to implement Matter.js physics. Delete bodies that have left the canvas. The result should appear as above. Feel free to be creative in how you draw the boxes!</p>
</div>
<h2 id="68-fixed-box2d-objects">6.8 Fixed Box2D Objects</h2>
<p>In the example just created, the <code>Box</code> objects appear at the mouse position and fall downwards due to the default gravity force. What if I wanted to add some immovable boundaries in the world that would block the path of the <code>Box</code> objects?</p>
<p>As briefly mentioned in 6.7, Matter.js makes this easy with the <code>isStatic</code> property.</p>
<pre class="codesplit" data-code-language="javascript">// Creating a fixed (static) boundary body
let options = { isStatic: true };
let boundary = Bodies.rectangle(x, y, w, h, options);</pre>
<p>I can then augment the Boxes example by writing a <code>Boundary</code> class and having each boundary create a static body. Notice how in this example the dimensions of each box are now randomized.</p>
<div data-type="example">
  <h3 id="example-63-falling-boxes-hitting-boundaries">Example 6.3: Falling boxes hitting boundaries</h3>
  <figure>
    <div data-type="embed" data-p5-editor="https://editor.p5js.org/natureofcode/sketches/WSoUy03ph" data-example-path="examples/06_libraries/6_3_boxes_and_boundaries"><img src="examples/06_libraries/6_3_boxes_and_boundaries/screenshot.png"></div>
    <figcaption></figcaption>
  </figure>
</div>
<pre class="codesplit" data-code-language="javascript">class Boundary {
  constructor(x, y, w, h) {
    //{!4} A boundary is a simple rectangle with x, y, width, and height. 
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    //{!1} Lock it in place by setting isStatic to true!
    let options = { isStatic: true };
    this.body = Bodies.rectangle(this.x, this.y, this.w, this.h, options);
    Composite.add(engine.world, this.body);
  }
  
  //{!6} Since it can never move, show() can draw it
  // the old-fashioned way, using the original
  // variables. No need to query Matter.js.  
  show() {
    rectMode(CENTER);
    fill(127);
    stroke(0);
    strokeWeight(2);    
    rect(this.x, this.y, this.w, this.h);
  }
}</pre>
<p></p>
<h2 id="69-complex-forms">6.9 Complex Forms</h2>
<p></p>
<figure class="half-width-right">
  <img src="images/06_libraries/06_libraries_4.png" alt="Figure 5.5">
  <figcaption>Figure 5.5</figcaption>
</figure>
<p>Now that I’ve demonstrated how easy it is to make simple geometric forms in Matter.js, let’s imagine that you want to have a more complex form, such as a little alien stick figure.</p>
<p>There are two strategies for making forms that are more advanced than a basic circle or square. One is to use a <code>Bodies.fromVertices()</code>. There is also a <code>Bodies.polygon()</code> function for a regular polygon (pentagon, hexagon, etc.) as well as a <code>Bodies.trapezoid()</code> function for a quadrilateral with at least one parallel side.</p>
<pre class="codesplit" data-code-language="javascript">// A regular hexagon (6 sided polygon)
let hexagon = Bodies.polygon(x, y, 6, radius);

// A trapezoid
let trapezoid = Bodies.trapezoid(x, y, width, height, slope);</pre>
<p>However, a <code>fromVertices()</code> creates the shape from array of vectors, which allows you to build a completely custom shape as a series of connected vertices.</p>
<div data-type="example">
  <h3 id="example-54-polygon-shapes">Example 5.4: Polygon shapes</h3>
  <figure>
    <div data-type="embed" data-p5-editor="https://editor.p5js.org/natureofcode/sketches/o3-Qpqu2i" data-example-path="examples/06_libraries/6_4_polygon_shapes"><img src="examples/06_libraries/6_4_polygon_shapes/screenshot.png"></div>
    <figcaption></figcaption>
  </figure>
</div>
<pre class="codesplit" data-code-language="javascript">
class CustomShape {
  constructor(x, y) {
    //{!6} An array of 5 vectors
    let vertices = [];
    vertices[4] = Vector.create(-15, 25);
    vertices[3] = Vector.create(-5, 20);
    vertices[2] = Vector.create(15, 0);
    vertices[1] = Vector.create(20, -15);
    vertices[0] = Vector.create(-10, -10);
    
    //{!2} Making a body from shaped by the vertices
    let options = { restitution: 1 };
    this.body = Bodies.fromVertices(x, y, vertices, options);

    Body.setVelocity(this.body, Vector.create(random(-5, 5), 0));
    Body.setAngularVelocity(this.body, 0.1);
    Composite.add(engine.world, this.body);
  }</pre>
<p>When creating a custom polygon in Matter.js, you must remember two important details.</p>
<figure>
  <img src="images/06_libraries/06_libraries_5.png" alt="Figure 5.6">
  <figcaption>Figure 5.6</figcaption>
</figure>
<ol>
  <li><strong>Order of vertices!</strong> If you are thinking in terms of pixels (as above) the vertices should be defined in counterclockwise order. (When they are translated to Box2D World vectors, they will actually be in clockwise order since the vertical axis is flipped.)</li>
  <li><strong>Convex shapes only!</strong> A concave shape is one where the surface curves inward. Convex is the opposite (see illustration below). Note how in a convex shape every internal angle must be 180 degrees or less. Matter.js is capable of handling collisions for concave shapes, you just need to build one out of multiple convex shapes! (More about that in a moment.)</li>
</ol><a data-type="indexterm" data-primary="Box2D" data-secondary="concave shapes and"></a>
<figure>
  <img src="images/06_libraries/06_libraries_6.png" alt="Figure 5.7: A concave shape can be drawn with multiple convex shapes. ">
  <figcaption>Figure 5.7: A concave shape can be drawn with multiple convex shapes. </figcaption>
</figure>
<p>Now, when it comes time to display the shape, I can no longer just use <code>rect()</code> or <code>ellipse()</code>. Since the shape is built out of custom vertices, it can be drawn with <code>beginShape()</code>, <code>endShape()</code>, and <code>vertex()</code> functions. While I could choose to store the pixel positions of the vertices in my own array for drawing, it’s best to query Matter.js. In this case, there’s no need use <code>translate()</code> or <code>rotate()</code> because the vertex positions are stored as the absolute “world” positions.</p>
<pre class="codesplit" data-code-language="javascript">  show() {
    fill(127);
    stroke(0);
    strokeWeight(2);
    // Start the shape
    beginShape();
    //{!3} Loop through the body vertices
    for (let v of this.body.vertices) {
      vertex(v.x, v.y);
    }
    // End the shape, closing it
    endShape(CLOSE);    
  }</pre>
<div data-type="exercise">
  <h3 id="exercise-64">Exercise 6.4</h3>
  <p>Using the <code>Bodies.fromVertices()</code>, create your own polygon design (remember, it must be convex). Some possibilities below.</p>
  <figure>
    <img src="images/06_libraries/06_libraries_7.png" alt=" ">
    <figcaption> </figcaption>
  </figure>
</div>
<p>A custom shape built from an array of vertices will get you pretty far. However, the convex shape requirement does limit the range of possibilities. The good news is that you can completely eliminate this restriction by creating a compound body made up of multiple shapes! Let’s return to the little alien creature and simplify the shape to be a thin rectangle with a circle on top.</p>
<p>Let’s start by making two single bodies, one rectangle and one circle. Then with <code>Body.create()</code> the shapes can be joined via a <code>parts</code> array.</p>
<p>Let’s see what this would look like with actual Matter.js code.</p>
<pre class="codesplit" data-code-language="javascript">// Making the bodies
let part1 = Bodies.rectangle(x, y, w, h);
let part2 = Bodies.circle(x, y, r);

// Joining the two bodies together in an array
let body = Body.create({ parts: [part1, part2] });

// Adding the compound body to the world
Composite.add(engine.world, body);</pre>
<p>The above looks pretty good, but sadly, if you run it, this is the result since both shapes are created at the same <code>x</code> and <code>y</code> position.</p>
<figure>
  <img src="images/06_libraries/06_libraries_8.png" alt="Figure 5.8">
  <figcaption>Figure 5.8</figcaption>
</figure>
<p>In this case, if I consider the center of the rectangle to be the center of the body, I can offset the center of the circle along the y-axis from the body’s center.</p>
<figure>
  <img src="images/06_libraries/06_libraries_9.png" alt="Figure 5.9">
  <figcaption>Figure 5.9</figcaption>
</figure>
<pre class="codesplit" data-code-language="javascript">// Making the bodies
let part1 = Bodies.rectangle(x, y, w, h);
let part2 = Bodies.circle(x, y - offset, r);</pre>
<p>Then, when it’s time to render the body, each part can be drawn individually relative to the center.</p>
<div data-type="example">
  <h3 id="example-55-multiple-shapes-on-one-body">Example 5.5: Multiple shapes on one body</h3>
  <figure>
    <div data-type="embed" data-p5-editor="https://editor.p5js.org/natureofcode/sketches/xxYF4I5bi" data-example-path="examples/06_libraries/6_5_compound_bodies"><img src="examples/06_libraries/6_5_compound_bodies/screenshot.png"></div>
    <figcaption></figcaption>
  </figure>
</div>
<pre class="codesplit" data-code-language="javascript"> 
 
show() {
    let a = this.body.angle;
    let pos = this.body.position;

    rectMode(CENTER);
    fill(127);
    stroke(0);
    strokeWeight(2);
    push();
    translate(pos.x, pos.y);
    rotate(a);
    //{!1} First the rectangle at (0,0)
    rect(0,0,this.w,this.h);
    //{!1} Then the ellipse offset at (0,-h/2)
    circle(0, -this.h/2, this.r * 2);
    pop();
  }

 void display() {
    Vec2 pos = box2d.getBodyPixelCoord(body);
    float a = body.getAngle();

    rectMode(CENTER);
    pushMatrix();
    translate(pos.x, pos.y);
    rotate(-a);
    fill(175);
    stroke(0);
    rect(0, 0, w, h);
    ellipse(0, -h/2, r*2, r*2);
    popMatrix();
  }</pre>
<p>Finishing off this section, I want to stress the following: the stuff you draw in your Processing window doesn’t magically experience physics simply because we created some Box2D bodies and shapes. These examples work because we very carefully matched how we draw our elements with how we defined the bodies and shapes we put into the Box2D world. If you accidentally draw your shape differently, you won’t get an error, not from Processing or from Box2D. However, your sketch will look odd and the physics won’t work correctly. For example, what if we had written:</p>
<pre class="codesplit" data-code-language="javascript">Vec2 offset = new Vec2(0,-h/2);</pre>
<p>when we created the shape, but:</p>
<pre class="codesplit" data-code-language="javascript">ellipse(0,h/2,r*2,r*2);</pre>
<p>when it came time to display the shape?</p>
<figure>
  <img src="images/06_libraries/06_libraries_10.png" alt=" ">
  <figcaption> </figcaption>
</figure>
<p>The results would look like the image above, where clearly, the collisions are not functioning as expected. This is not because the physics is broken; it’s because we did not communicate properly with Box2D, either when we put stuff in the magic world or queried the world for positions.</p>
<div data-type="exercise">
  <h3 id="exercise-55-1">Exercise 5.5</h3>
  <p>Make your own little alien being using multiple shapes attached to a single body. Try using more than one polygon to make a concave shape. Remember, you aren’t limited to using the shape drawing functions in Processing; you can use images, colors, add hair with lines, etc. Think of the Box2D shapes only as skeletons for your creative and fantastical design!</p>
</div>
<h2 id="511-feeling-attachedbox2d-joints">5.11 Feeling Attached—Box2D Joints</h2><a data-type="indexterm" data-primary="joint (Box2D element)"></a>
<figure class="half-width-right">
  <img src="images/06_libraries/06_libraries_11.png" alt="Figure 5.10">
  <figcaption>Figure 5.10</figcaption>
</figure>
<p>Box2D joints allow you to connect one body to another, enabling more advanced simulations of swinging pendulums, elastic bridges, squishy characters, wheels spinning on an axle, etc. There are many different kinds of Box2D joints. In this chapter we’re going to look at three: distance joints, revolute joints, and “mouse” joints.</p><a data-type="indexterm" data-primary="distance joints"></a><a data-type="indexterm" data-primary="joint (Box2D element)" data-secondary="distance"></a>
<p>Let’s begin with a distance joint, a joint that connects two bodies with a fixed length. The joint is attached to each body at a specified anchor point (a point relative to the body’s center). For any Box2D joint, we need to follow these steps. This, of course, is similar to the methodology we used to build bodies and shapes, with some quirks.</p>
<p><strong><em>Step 1. Make sure you have two bodies ready to go.</em></strong><strong><em>Step 2. Define the joint.</em></strong><strong><em>Step 3. Configure the joint’s properties (What are the bodies? Where are the anchors? What is its rest length? Is it elastic or rigid?)</em></strong><strong><em>Step 4. Create the joint.</em></strong></p>
<p>Let’s assume we have two <code>Particle</code> objects that each store a reference to a Box2D <code>Body</code> object. We’ll call them particles <code>p1</code> and <code>p2</code>.</p>
<pre class="codesplit" data-code-language="javascript">Particle p1 = new Particle();
Particle p2 = new Particle();</pre><a data-type="indexterm" data-primary="DistanceJointDef (Box2D joint type)"></a>
<p>OK, onto Step 2. Let’s define the joint.</p>
<pre class="codesplit" data-code-language="javascript">DistanceJointDef djd = new DistanceJointDef();</pre>
<p>Easy, right? Now it’s time to configure the joint. First we tell the joint which two bodies it connects:</p>
<pre class="codesplit" data-code-language="javascript">djd.bodyA = p1.body;
djd.bodyB = p2.body;</pre><a data-type="indexterm" data-primary="rest length (Box2D joint element)"></a>
<p>Then we set up a rest length. Remember, if our rest length is in pixels, we need to convert it!</p>
<pre class="codesplit" data-code-language="javascript">djd.length = box2d.scalarPixelsToWorld(10);</pre><a data-type="indexterm" data-primary="dampingRatio setting (Box2D joint element)"></a><a data-type="indexterm" data-primary="frequencyHz setting (Box2D joint element)"></a>
<p>A distance joint also includes two optional settings that can make the joint soft, like a spring connection: <code>frequencyHz</code> and <code>dampingRatio</code>.</p>
<pre class="codesplit" data-code-language="javascript">  // Measured in Hz, like the frequency of harmonic
  // oscillation; try values between 1 and 5.
  djd.frequencyHz  = ___;
  // Dampens the spring; typically a number between 0 and 1.
  djd.dampingRatio = ___;</pre>
<p>Finally, we create the joint.</p>
<pre class="codesplit" data-code-language="javascript">DistanceJoint dj = (DistanceJoint) box2d.world.createJoint(djd);</pre>
<p>Box2D won’t keep track of what kind of joint we are making, so we have to cast it as a <code>DistanceJoint</code> upon creation.</p>
<p>We can create Box2D joints anywhere in our Processing sketch. Here’s an example of how we might write a class to describe two Box2D bodies connected with a single joint.</p>
<div data-type="example">
  <h3 id="example-56-distancejoint">Example 5.6: DistanceJoint</h3>
  <p>{p5 sketch link}</p>
  <figure>
    <img src="images/06_libraries/06_libraries_12.png" alt=" ">
    <figcaption> </figcaption>
  </figure>
</div>
<pre class="codesplit" data-code-language="javascript">class Pair {

  //{!2} Two objects that each have a Box2D body
  Particle p1;
  Particle p2;
  //{!1} Arbitrary rest length
  float len = 32;

  Pair(float x, float y) {
    //{!2} Problems can result if the bodies are initialized at the same position.
    p1 = new Particle(x,y);
    p2 = new Particle(x+random(-1,1),y+random(-1,1));

    // Making the joint!
    DistanceJointDef djd = new DistanceJointDef();
    djd.bodyA = p1.body;
    djd.bodyB = p2.body;
    djd.length = box2d.scalarPixelsToWorld(len);
    djd.frequencyHz = 0;  // Try a value less than 5
    djd.dampingRatio = 0; // Ranges between 0 and 1

    //{!1} Make the joint.  Note that we aren't storing a reference to the joint anywhere! We might need to someday, but for now it's OK.
    DistanceJoint dj = (DistanceJoint) box2d.world.createJoint(djd);
  }

  void display() {
    Vec2 pos1 = box2d.getBodyPixelCoord(p1.body);
    Vec2 pos2 = box2d.getBodyPixelCoord(p2.body);
    stroke(0);
    line(pos1.x, pos1.y, pos2.x, pos2.y);

    p1.display();
    p2.display();
  }
}</pre>
<div data-type="exercise">
  <h3 id="exercise-56-1">Exercise 5.6</h3>
  <p>Create a simulation of a bridge by using distance joints to connect a sequence of circles (or rectangles) as illustrated to the right. Assign a density of zero to lock the endpoints in place. Experiment with different values to make the bridge more or less “springy.” It should also be noted that the joints themselves have no physical geometry, so in order for your bridge not to have holes, spacing between the nodes will be important.</p>
  <figure>
    <img src="images/06_libraries/06_libraries_13.png" alt=" ">
    <figcaption> </figcaption>
  </figure>
</div>
<figure class="half-width-right">
  <img src="images/06_libraries/06_libraries_14.png" alt="Figure 5.11">
  <figcaption>Figure 5.11</figcaption>
</figure><a data-type="indexterm" data-primary="joint (Box2D element)" data-secondary="revolute type"></a><a data-type="indexterm" data-primary="revolute joint type (Box2D)"></a>
<p>Another joint you can create in Box2D is a <em>revolute joint</em>. A revolute joint connects two Box2D bodies at a common anchor point, which can also be referred to as a “hinge.” The joint has an “angle” that describes the relative rotation of each body. To use a revolute joint, we follow the same steps we did with the distance joint.</p>
<h3 id="step-1-make-sure-you-have-two-bodies-ready-to-go">Step 1: Make sure you have two bodies ready to go.</h3>
<p>Let’s assume we have two <code>Box</code> objects, each of which stores a reference to a Box2D body.</p>
<pre class="codesplit" data-code-language="javascript">Box box1 = new Box();
Box box2 = new Box();</pre>
<h3 id="step-2-define-the-joint">Step 2: Define the joint.</h3><a data-type="indexterm" data-primary="RevoluteJointDef object (Box2D joint element)"></a>
<p>Now we want a <code>RevoluteJointDef</code> object.</p>
<pre class="codesplit" data-code-language="javascript">RevoluteJointDef rjd = new RevoluteJointDef();</pre>
<h3 id="step-3-configure-the-joints-properties">Step 3: Configure the joint’s properties.</h3><a data-type="indexterm" data-primary="revolute joint type (Box2D)" data-secondary="properties" data-tertiary="configuring"></a>
<p>The most important properties of a revolute joint are the two bodies it connects as well as their mutual anchor point (i.e. where they are connected). They are set with the function <code>initialize()</code>.</p>
<pre class="codesplit" data-code-language="javascript">rjd.initialize(box1.body, box2.body, box1.body.getWorldCenter());</pre>
<p>Notice how the first two arguments specify the bodies and the second point specifies the anchor, which in this case is located at the center of the first body.</p>
<p>An exciting feature of a <code>RevoluteJoint</code> object is that you can motorize it so it spins autonomously. For example:</p>
<pre class="codesplit" data-code-language="javascript">// Turn on the motor.
rjd.enableMotor = true;
 // How fast is the motor?
rjd.motorSpeed = PI*2;
// How powerful is the motor?
rjd.maxMotorTorque = 1000.0;</pre>
<p>The motor can be enabled and disabled while the program is running.</p>
<p>Finally, the ability for a revolute joint to spin can be constrained between two angles. (By default, it can rotate a full 360 degrees, or <code>TWO_PI</code> radians.)</p>
<pre class="codesplit" data-code-language="javascript">rjd.enableLimit = true;
rjd.lowerAngle = -PI/8;
rjd.upperAngle = PI/8;</pre>
<h3 id="step-4-create-the-joint">Step 4: Create the joint.</h3>
<pre class="codesplit" data-code-language="javascript">RevoluteJoint joint = (RevoluteJoint) box2d.world.createJoint(rjd);</pre>
<p>Let’s take a look at all of these steps together in a class called <code>Windmill</code>, which connects two boxes with a revolute joint. In this case, <code>box1</code> has a density of zero, so only <code>box2</code> spins around a fixed point.</p>
<div data-type="example">
  <h3 id="example-57-spinning-windmill">Example 5.7: Spinning Windmill</h3>
  <p>{p5 sketch link}</p>
  <figure>
    <img src="images/06_libraries/06_libraries_15.png" alt=" ">
    <figcaption> </figcaption>
  </figure>
</div>
<pre class="codesplit" data-code-language="javascript">class Windmill {

  //{!3} The “Windmill” is two boxes and one joint.
  RevoluteJoint joint;
  Box box1;
  Box box2;

  Windmill(float x, float y) {

    //{!2} In this example, the Box class expects a Boolean argument that will be used to determine if the Box is fixed or not.  See website for the Box class code.
    box1 = new Box(x, y, 120, 10, false);
    box2 = new Box(x, y, 10, 40, true);

    RevoluteJointDef rjd = new RevoluteJointDef();
    //{!1} The joint connects two bodies and is anchored at the center of the first body.
    rjd.initialize(box1.body, box2.body, box1.body.getWorldCenter());



    //{!3} A motor!
    rjd.motorSpeed = PI*2;
    rjd.maxMotorTorque = 1000.0;
    rjd.enableMotor = true;

    //{!1} Create the Joint.
    joint = (RevoluteJoint) box2d.world.createJoint(rjd);
  }

  //{!4} Turning the motor on or off
  void toggleMotor() {
    boolean motorstatus = joint.isMotorEnabled();
    joint.enableMotor(!motorstatus);
  }

  void display() {
    box1.display();
    box2.display();
  }
}</pre>
<div data-type="exercise">
  <h3 id="exercise-57-1">Exercise 5.7</h3>
  <figure class="half-width-right">
    <img src="images/06_libraries/06_libraries_16.png" alt=" ">
    <figcaption> </figcaption>
  </figure>
  <p>Use a revolute joint for the wheels of a car. Use motors so that the car drives autonomously. Try using a chain shape for the road’s surface.</p>
  <figure>
    <img src="images/06_libraries/06_libraries_17.png" alt=" ">
    <figcaption> </figcaption>
  </figure>
</div><a data-type="indexterm" data-primary="joint (Box2D element)" data-secondary="mouse type"></a><a data-type="indexterm" data-primary="mouse joint (Box2D Joint type)"></a><a data-type="indexterm" data-primary="mouse joint (Box2D joint type)" data-secondary="setTransform() function"></a><a data-type="indexterm" data-primary="setTransform() function (Box2D)"></a>
<p>Before we look at the <code>MouseJoint</code> object itself, let’s ask ourselves why we even need it in the first place. If you look at the Box2D documentation, there is a function called <code>setTransform()</code> that specifically “sets the position of the body’s origin and rotation (radians).” If a body has a position, can’t we just assign the body’s position to the mouse?</p>
<pre class="codesplit" data-code-language="javascript">Vec2 mouse = box2d.coordPixelsToWorld(x, y);
body.setTransform(mouse, 0);</pre>
<p>While this will in fact move the body, it will also have the unfortunate result of breaking the physics. Let’s imagine you built a teleportation machine that allows you to teleport from your bedroom to your kitchen (good for late-night snacking). Now, go ahead and rewrite Newton’s laws of motion to account for the possibility of teleportation. Not so easy, right? Box2D has the same problem. If you manually assign the position of an body, it’s like saying “teleport that body” and Box2D no longer knows how to compute the physics properly. However, Box2D does allow you to tie a rope to yourself and get a friend of yours to stand in the kitchen and drag you there. This is what the <code>MouseJoint</code> does. It’s like a string you attach to a body and pull towards a target.</p>
<p>Let’s look at making this joint, assuming we have a <code>Box</code> object called <code>box</code>. This code will look identical to our distance joint with one small difference.</p>
<pre class="codesplit" data-code-language="javascript">// Just like before, define the Joint.
MouseJointDef md = new MouseJointDef();

// Whoa, this is new!
md.bodyA = box2d.getGroundBody(); //[bold]
// Attach the Box body.
md.bodyB = box.body;

// Set properties.
md.maxForce = 5000.0;
md.frequencyHz = 5.0;
md.dampingRatio = 0.9;

// Create the joint.
MouseJoint mouseJoint = (MouseJoint) box2d.world.createJoint(md);.</pre><a data-type="indexterm" data-primary="getGroundBody() function (Box2D joint element)"></a>
<p>So, what’s this line of code all about?</p>
<pre class="codesplit" data-code-language="javascript">md.bodyA = box2d.getGroundBody(); //[bold]</pre>
<p>Well, as we’ve stated, a joint is a connection between <em>two</em> bodies. With a mouse joint, we’re saying that the second body is, well, the ground. Hmm. What the heck is the <em>ground</em> in Box2D? One way to imagine it is to think of the screen as the ground. What we’re doing is making a joint that connects a rectangle drawn on the window with the Processing window itself. And the point in the window to which the connection is tied is a moving target.</p>
<p>Once we have a mouse joint, we’ll want to update the target position continually while the sketch is running.</p>
<pre class="codesplit" data-code-language="javascript">Vec2 mouseWorld = box2d.coordPixelsToWorld(mouseX,mouseY);
mouseJoint.setTarget(mouseWorld);</pre>
<p>To make this work in an actual Processing sketch, we’ll want to have the following:</p>
<ol>
  <li><strong><em>Box class</em></strong><code>—</code>An object that references a Box2D body.</li>
  <li><strong><em>Spring class</em></strong><code>—</code>An object that manages the mouse joint that drags the <code>Box</code> object around.</li>
  <li><strong><em>Main tab</em></strong><code>—</code>Whenever <code>mousePressed()</code> is called, the mouse joint is created; whenever <code>mouseReleased()</code> is called, the mouse joint is destroyed. This allows us to interact with a body only when the mouse is pressed.</li>
</ol>
<p>Let’s take a look at the main tab. You can find the rest of the code for the <code>Box</code> and <code>Spring</code> classes via the book website.</p>
<div data-type="example">
  <h3 id="example-58-mousejoint-demonstration">Example 5.8: MouseJoint demonstration</h3>
  <p>{p5 sketch link}</p>
  <figure>
    <img src="images/06_libraries/06_libraries_18.png" alt=" ">
    <figcaption> </figcaption>
  </figure>
</div>
<pre class="codesplit" data-code-language="javascript">Box2DProcessing box2d;

// One Box
Box box;
//{!1} Object to manage MouseJoint
Spring spring;

void setup() {
  size(400, 300);
  box2d = new Box2DProcessing(this);
  box2d.createWorld();

  box = new Box(width/2, height/2);
  //{!1} The MouseJoint is really null until we click the mouse.
  spring = new Spring();
}

void mousePressed() {
  //{!1} Was the mouse clicked inside the Box?
  if (box.contains(mouseX, mouseY)) {
    //{!1} If so, attach the MouseJoint.
    spring.bind(mouseX,mouseY,box);
  }
}

void mouseReleased() {
  //{!1} When the mouse is released, we’re done with the MouseJoint.
  spring.destroy();
}

void draw() {
  background(255);

  box2d.step();

  //{!1} Always update the MouseJoint’s target.
  spring.update(mouseX, mouseY);

  box.display();
  spring.display();
}</pre>
<div data-type="exercise">
  <h3 id="exercise-58-1">Exercise 5.8</h3>
  <p>Use a mouse joint to move a Box2D body around the screen according to an algorithm or input other than the mouse. For example, assign it a position according to Perlin noise or key presses. Or build your own controller using an Arduino.</p>
</div><a data-type="indexterm" data-primary="kinematic (body type)" data-secondary="MouseJoints and"></a>
<p>It’s worth noting that while the technique for dragging an object around using a <code>MouseJoint</code> is useful, Box2D also allows a body to have a <code>KINEMATIC</code> type.</p>
<pre class="codesplit" data-code-language="javascript">BodyDef bd = new BodyDef();
// Setting the body type to Kinematic
bd.type = BodyType.KINEMATIC;</pre>
<figure class="half-width-right">
  <img src="images/06_libraries/06_libraries_19.png" alt="Figure 5.12">
  <figcaption>Figure 5.12</figcaption>
</figure>
<p>Kinematic bodies can be controlled by the user by setting their velocity directly. For example, let’s say you want an object to follow a target (like your mouse). You could create a vector that points from a body’s position to a target.</p>
<pre class="codesplit" data-code-language="javascript">Vec2 pos = body.getWorldCenter();
Vec2 target = box2d.coordPixelsToWorld(mouseX, mouseY);
// A vector pointing from the body position to the Mouse
Vec2 v = target.sub(pos);</pre>
<p>Once you have that vector, you could assign it to the body’s velocity so that it moves to the target.</p>
<pre class="codesplit" data-code-language="javascript">// Assigning a body’s velocity directly, overriding physics!
body.setLinearVelocity(v);</pre>
<p>You can also do the same with angular velocity (or leave it alone and allow the physics to take over).</p>
<p>It is important to note that kinematic bodies do not collide with other kinematic or static bodies. In these cases, the mouse joint strategy is preferable.</p>
<div data-type="exercise">
  <h3 id="exercise-59-1">Exercise 5.9</h3>
  <p>Redo Exercise 5.8, but use a kinematic body instead.</p>
</div>
<h2 id="512-bringing-it-all-back-home-to-forces">5.12 Bringing It All Back Home to Forces</h2>
<p>In Chapter 2, we spent a lot of time thinking about building environments with multiple forces. An object might respond to gravitational attraction, wind, air resistance, etc. Clearly there are forces at work in Box2D as we watch rectangles and circles spin and fly around the screen. But so far, we’ve only had the ability to manipulate a single global force—gravity.</p>
<pre class="codesplit" data-code-language="javascript">  box2d = new Box2DProcessing(this);
  box2d.createWorld();
  // Setting the global gravity force
  box2d.setGravity(0, -20);</pre><a data-type="indexterm" data-primary="applyForce() function (Box2D)"></a><a data-type="indexterm" data-primary="forces" data-secondary="applyForce() function"></a>
<p>If we want to use any of our Chapter 2 techniques with Box2D, we need look no further than our trusty <code>applyForce()</code> function. In our <code>Mover</code> class we wrote a function called <code>applyForce()</code>, which received a vector, divided it by mass, and accumulated it into the mover’s acceleration. With Box2D, the same function exists, but we don’t need to write it ourselves. Instead, we can call the Box2D body’s <code>applyForce()</code> function!</p>
<pre class="codesplit" data-code-language="javascript">class Box {
  Body body;

  void applyForce(Vec2 force) {
    Vec2 pos = body.getWorldCenter();
    //{!1} Calling the Body's applyForce() function
    body.applyForce(force, pos);
  }
}</pre>
<p>Here we are receiving a force vector and passing it along to the Box2D <code>Body</code> object. The key difference is that Box2D is a more sophisticated engine than our examples from Chapter 2. Our earlier forces examples assumed that the force was always applied at the mover’s center. Here we get to specify exactly where on the body the force is applied. In the above code, we’re just applying it to the center by asking the body for its center, but this could be adjusted.</p>
<p>Let’s say we wanted to use a gravitational attraction force. Remember the code we wrote back in Chapter 2 in our <code>Attractor</code> class?</p>
<pre class="codesplit" data-code-language="javascript">PVector attract(Mover m) {
  PVector force = PVector.sub(position, m.position);
  float distance = force.mag();
  distance = constrain(distance, 5.0, 25.0);
  force.normalize();
  float strength = (g * mass * m.mass) / (distance * distance);
  force.mult(strength);
  return force;
}</pre>
<p>We can rewrite the exact same function using <code>Vec2</code> instead and use it in a Box2D example. Note how for our force calculation we can stay completely within the Box2D coordinate system and never think about pixels.</p>
<pre class="codesplit" data-code-language="javascript">Vec2 attract(Mover m) {
  //{!2} We have to ask Box2D for the positions first!
  Vec2 pos = body.getWorldCenter();
  Vec2 moverPos = m.body.getWorldCenter();
  Vec2 force = pos.sub(moverPos);
  float distance = force.length();
  distance = constrain(distance, 1, 5);
  force.normalize();
  float strength = (G * 1 * m.body.m_mass) / (distance * distance);
  //{!1} Remember, it’s mulLocal() for Vec2.
  force.mulLocal(strength);
  return force;
}</pre>
<div data-type="exercise">
  <h3 id="exercise-510-1">Exercise 5.10</h3>
  <p>Take any example you made previously using a force calculation and bring that force calculation into Box2D.</p>
  <figure>
    <img src="images/06_libraries/06_libraries_20.png" alt=" ">
    <figcaption> </figcaption>
  </figure>
</div>
<h2 id="513-collision-events">5.13 Collision Events</h2><a data-type="indexterm" data-primary="collisions" data-secondary="Box2D and"></a>
<p>Now we’ve seen a survey of what can be done with Box2D. Since this book is not called “The Nature of Box2D,” it’s not my intention to cover every single possible feature of the Box2D engine. But hopefully by looking at the basics of building bodies, shapes, and joints, when it comes time to use an aspect of Box2D that we haven’t covered, the skills we’ve gained here will make that process considerably less painful. There is one more feature of Box2D, however, that I do think is worth covering.</p>
<p>Let’s ask a question you’ve likely been wondering about:</p>
<p><em>What if I want something to happen when two Box2D bodies collide? I mean, don’t get me wrong—I’m thrilled that Box2D is handling all of the collisions for me. But if it takes care of everything for me, how am I supposed to know when things are happening?</em></p>
<p>Your first thoughts when considering an event during which two objects collide might be as follows: Well, if I know all the bodies in the system, and I know where they are all located, then I can just start comparing the positions, see which ones are intersecting, and determine that they’ve collided. That’s a nice thought, but hello??!? The whole point of using Box2D is that Box2D will take care of that for us. If we are going to do the geometry to test for intersection ourselves, then all we’re doing is re-implementing Box2D.</p><a data-type="indexterm" data-primary="ContactListener class (JBox2D)"></a><a data-type="indexterm" data-primary="interfaces"></a><a data-type="indexterm" data-primary="JBox2D" data-secondary="ContactListener class"></a>
<p>Of course, Box2D has thought of this problem before. It’s a pretty common one. After all, if you intend to make a bazillion dollars selling some game called Angry Birds, you better well make something happen when an ill-tempered pigeon smashes into a cardboard box. Box2D alerts you to moments of collision with something called an “interface.” It’s worth learning about interfaces, an advanced feature of object-oriented programming. You can take a look at the Java Interface Tutorial as well as the JBox2D <code>ContactListener</code> class. (I have also included an example on the website that demonstrates using the interface directly.)</p><a data-type="indexterm" data-primary="beginContact() function (Box2DProcessing)"></a><a data-type="indexterm" data-primary="collisions" data-secondary="beginContact() function (Box2DProcessing)"></a>
<p>If you are using Box2D-for-Processing, as we are here, you don’t need to implement your own interface. Detecting collision events is done through a callback function. Much like <code>mousePressed()</code> is triggered when the mouse is pressed, <code>beginContact()</code> is triggered when two shapes collide.</p>
<pre class="codesplit" data-code-language="javascript">// The mousePressed event with which we are comfortable.
void mousePressed() {
  println("The mouse was pressed!");
}

// What our "beginContact" event looks like.
void beginContact(Contact cp) {
  println("Something collided in the Box2D World!");
}</pre>
<p>Before the above will work, you must first let Box2D-for-Processing know you intend to listen for collisions. (This allows the library to reduce overhead by default; it won’t bother listening if it doesn’t have to.)</p>
<pre class="codesplit" data-code-language="javascript">void setup() {
  box2d = new Box2DProcessing(this);
  box2d.createWorld();
  //{!1} Add this line if you want to listen for collisions.
  box2d.listenForCollisions();
}</pre>
<p>There are four collision event callbacks.</p><a data-type="indexterm" data-primary="endContact() function (Box2DProcessing)"></a><a data-type="indexterm" data-primary="postSolve() function (Box2DProcessing)"></a><a data-type="indexterm" data-primary="preSolve() function (Box2DProcessing)"></a>
<ol>
  <li><code>beginContact()</code> —Triggered whenever two shapes first come into contact with each other.</li>
  <li><code>endContact()</code> —Triggered when two shapes cease to touch.</li>
  <li><code>preSolve()</code> —Triggered before Box2D solves the outcome of the collision, i.e. before <code>beginContact()</code>. It can be used to disable a collision if necessary.</li>
  <li><code>postSolve()</code> —Triggered after the outcome of the collision is solved. It allows you to gather information about that “solution” (known as an “impulse”).</li>
</ol>
<p>The details behind <code>preSolve()</code> and <code>postSolve()</code> are beyond the scope of this book; however, we are going to take a close look at <code>beginContact()</code>, which will cover the majority of conventional cases in which you want to trigger an action when a collision occurs. <code>endContact()</code> works identically to <code>beginContact()</code>, the only difference being that it occurs the moment bodies separate.</p>
<p><code>beginContact()</code> is written as follows:</p>
<pre class="codesplit" data-code-language="javascript">void beginContact(Contact cp) {

}</pre><a data-type="indexterm" data-primary="Contact objects (Box2D-for-Processing)"></a>
<p>Notice that the function above includes an argument of type <code>Contact</code>. A <code>Contact</code> object includes all the data associated with a collision—the geometry and the forces. Let’s say we have a Processing sketch with <code>Particle</code> objects that store a reference to a Box2D body. Here is the process we are going to follow.</p>
<h3 id="step-1-contact-could-you-tell-me-what-two-things-collided">Step 1: Contact, could you tell me what two things collided?</h3>
<p>Now, what has collided here? Is it the bodies? The shapes? The fixtures? Box2D detects collisions between shapes; after all, these are the entities that have geometry. However, because shapes are attached to bodies with fixtures, what we really want to ask Box2D is: “Could you tell me which two fixtures collided?”</p>
<pre class="codesplit" data-code-language="javascript">// The contact stores the fixtures as A and B.
Fixture f1 = cp.getFixtureA();
Fixture f2 = cp.getFixtureB();</pre>
<h3 id="step-2-fixtures-could-you-tell-me-which-body-you-are-attached-to">Step 2: Fixtures, could you tell me which body you are attached to?</h3>
<pre class="codesplit" data-code-language="javascript">// getBody() gives us the body to which the Fixture is attached.
Body b1 = f1.getBody();
Body b2 = f2.getBody();</pre>
<h3 id="step-3-bodies-could-you-tell-me-which-particles-you-are-associated-with">Step 3: Bodies, could you tell me which Particles you are associated with?</h3>
<p>OK, this is the harder part. After all, Box2D doesn’t know anything about our code. Sure, it is doing all sorts of stuff to keep track of the relationships between shapes and bodies and joints, but it’s up to us to manage our own objects and their associations with Box2D elements. Luckily for us, Box2D provides a function that allows us to attach our Processing object (a <code>Particle</code>) to a Box2D body via the <code>setUserData()</code> and <code>getUserData()</code> methods.</p>
<p>Let’s take a look at the constructor in our <code>Particle</code> class where the body is made. We are expanding our body-making procedure by one line of code, noted below.</p>
<pre class="codesplit" data-code-language="javascript">class Particle {
  Body body;

  Particle(float x, float y, float r) {
    BodyDef bd = new BodyDef();
    bd.position = box2d.coordPixelsToWorld(x, y);
    bd.type = BodyType.DYNAMIC;
    body = box2d.createBody(bd);
    CircleShape cs = new CircleShape();
    cs.m_radius = box2d.scalarPixelsToWorld(r);
    body.createFixture(fd,1);

    //{!1 .bold} "this" refers to this Particle object.
    // We are telling the Box2D Body to store a
    // reference to this Particle that we can
    // access later.
    body.setUserData(this);
  }</pre>
<p>Later, in our <code>addContact()</code> function, once we know the body, we can access the <code>Particle</code> object with <code>getUserData()</code>.</p>
<div data-type="example">
  <h3 id="example-59-collisionlistening">Example 5.9: CollisionListening</h3>
  <p>{p5 sketch link}</p>
  <figure>
    <img src="images/06_libraries/06_libraries_21.png" alt=" ">
    <figcaption> </figcaption>
  </figure>
</div>
<pre class="codesplit" data-code-language="javascript">void beginContact(Contact cp) {

  Fixture f1 = cp.getFixtureA();
  Fixture f2 = cp.getFixtureB();

  Body b1 = f1.getBody();
  Body b2 = f2.getBody();

  //{!2} When we pull the “user data” object out of the Body object, we have to remind our program that it is a Particle object.  Box2D doesn’t know this.
  Particle p1 = (Particle) b1.getUserData();
  Particle p2 = (Particle) b2.getUserData();

  //{!2} Once we have the particles, we can do anything to them.  Here we just call a function that changes their color.
  p1.change();
  p2.change();
}</pre>
<p>Now, in many cases, we cannot assume that the objects that collided are all <code>Particle</code> objects. We might have a sketch with <code>Boundary</code> objects, <code>Particle</code> objects, <code>Box</code> objects, etc. So often we will have to query the “user data” and find out what kind of object it is before proceeding.</p>
<pre class="codesplit" data-code-language="javascript">  // Getting a generic object
  Object o1 = b1.getUserData();
  //{!1} Asking that object if it’s a Particle
  if (o1.getClass() == Particle.class) {
    Particle p = (Particle) o1;
    p.change();
  }</pre>
<p>It should also be noted that due to how Box2D triggers these callbacks, you cannot create or destroy Box2D entities inside of <code>beginContact()</code>, <code>endContact()</code>, <code>preSolve()</code>, or <code>postSolve()</code>. If you want to do this, you’ll need to set a variable inside an object (something like: <code>markForDeletion = true</code>), which you check during <code>draw()</code> and then delete objects.</p>
<div data-type="exercise">
  <h3 id="exercise-511-1">Exercise 5.11</h3>
  <p>Consider how polymorphism could help in the above case. Build an example in which several classes extend one class and therefore eliminate the need for such testing.</p>
</div>
<div data-type="exercise">
  <h3 id="exercise-512-1">Exercise 5.12</h3>
  <p>Create a simulation in which <code>Particle</code> objects disappear when they collide with one another. Use the methodology I just described.</p>
</div>
<h2 id="514-a-brief-interludeintegration-methods">5.14 A Brief Interlude—Integration Methods</h2><a data-type="indexterm" data-primary="integration"></a>
<p>Has the following ever happened to you? You’re at a fancy cocktail party regaling your friends with tall tales of software physics simulations. Someone pipes up: “Enchanting! But what integration method are you using?” “What?!” you think to yourself. “Integration?”</p>
<p>Maybe you’ve heard the term before. Along with “differentiation,” it’s one of the two main operations in calculus. Right, calculus. The good news is, we’ve gotten through about 90% of the material in this book related to physics simulation and we haven’t really needed to dive into calculus. But as we’re coming close to finishing this topic, it’s worth taking a moment to examine the calculus behind what we have been doing and how it relates to the methodology in certain physics libraries (like Box2D and the upcoming toxiclibs).</p><a data-type="indexterm" data-primary="derivatives"></a><a data-type="indexterm" data-primary="differentiation"></a>
<p>Let’s begin by answering the question: “What does integration have to do with position, velocity, and acceleration?” Well, first let’s define <strong><em>differentiation</em></strong>, the process of finding a “derivative.” The derivative of a function is a measure of how a function changes over time. Consider position and its derivative. position is a point in space, while velocity is change in position over time. Therefore, velocity can be described as the “derivative” of position. What is acceleration? The change in velocity over time—i.e. the “derivative” of velocity.</p>
<p>Now that we understand the derivative (differentiation), we can define the integral (integration) as the inverse of the derivative. In other words, the integral of an object’s velocity over time tells us the object’s new position when that time period ends. position is the integral of velocity, and velocity is the integral of acceleration. Since our physics simulation is founded upon the process of calculating acceleration based on forces, we need integration to figure out where the object is after a certain period of time (like one frame of animation!)</p>
<p>So we’ve been doing integration all along! It looks like this:</p><a data-type="indexterm" data-primary="Euler integration"></a><a data-type="indexterm" data-primary="Euler" data-secondary="Leonhard"></a><a data-type="indexterm" data-primary="integration" data-secondary="Euler integration"></a>
<p>The above methodology is known as Euler integration (named for the mathematician Leonhard Euler, pronounced “Oiler”) or the Euler method. It’s essentially the simplest form of integration and very easy to implement in our code (see the two lines above!) However, it is not necessarily the most efficient form, nor is it close to being the most accurate. Why is Euler inaccurate? Let’s think about it this way. When you drive a car down the road pressing the gas pedal with your foot and accelerating, does the car sit in one position at time equals one second, then disappear and suddenly reappear in a new position at time equals two seconds, and do the same thing for three seconds, and four, and five? No, of course not. The car moves continuously down the road. But what’s happening in our Processing sketch? A circle is at one position at frame 0, another at frame 1, another at frame 2. Sure, at thirty frames per second, we’re seeing the illusion of motion. But we only calculate a new position every <code>N</code> units of time, whereas the real world is perfectly continuous. This results in some inaccuracies, as shown in the diagram below:</p>
<figure>
  <img src="images/06_libraries/06_libraries_22.png" alt="Figure 5.13">
  <figcaption>Figure 5.13</figcaption>
</figure>
<p>The “real world” is the curve; Euler simulation is the series of line segments.</p>
<p>One option to improve on Euler is to use smaller timesteps—instead of once per frame, we could recalculate an object’s position twenty times per frame. But this isn’t practical; our sketch would then run too slowly.</p><a data-type="indexterm" data-primary="Euler integration" data-secondary="symplectic Euler (Box2D)"></a><a data-type="indexterm" data-primary="symplectic Euler (Box2D)"></a>
<p>I still believe that Euler is the best method for learning the basics, and it’s also perfectly adequate for most of the projects we might make in Processing. Anything we lose in efficiency or inaccuracy we make up in ease of use and understandability. For better accuracy, Box2D uses something called symplectic Euler or semi-explicit Euler, a slight modification of Euler.</p><a data-type="indexterm" data-primary="integration" data-secondary="Runge-Kutta method"></a><a data-type="indexterm" data-primary="Kutta" data-secondary="M. W."></a><a data-type="indexterm" data-primary="Runge" data-secondary="C."></a><a data-type="indexterm" data-primary="Runge-Kutta method"></a>
<p>There is also an integration method called Runge-Kutta (named for German mathematicians C. Runge and M. W. Kutta), which is used in some physics engines.</p><a data-type="indexterm" data-primary="particle systems" data-secondary="Verlet integration and"></a><a data-type="indexterm" data-primary="Verlet integration"></a>
<p>A very popular integration method that our next physics library uses is known as “Verlet integration.” A simple way to describe Verlet integration is to think of our typical motion algorithm without velocity. After all, we don’t really need to store the velocity. If we always know where an object was at one point in time and where it is now, we can extrapolate its velocity. Verlet integration does precisely this, though instead of having a variable for velocity, it calculates velocity while the program is running. Verlet integration is particularly well suited for particle systems, especially particle systems with spring connections between the particles. We don’t need to worry about the details because toxiclibs, as we’ll see below, takes care of them for us. However, if you are interested, here is the seminal paper on Verlet physics, from which just about every Verlet computer graphics simulation is derived: "Advanced Character Physics". And of course, you can find out more about Verlet integration from Wikipedia.</p>
<h2 id="515-verlet-physics-with-toxiclibs">5.15 Verlet Physics with toxiclibs</h2><a data-type="indexterm" data-primary="Processing" data-secondary="toxiclibs and"></a><a data-type="indexterm" data-primary="Schmidt" data-secondary="Karsten"></a><a data-type="indexterm" data-primary="toxiclibs"></a><a data-type="indexterm" data-primary="Verlet integration" data-secondary="toxiclibs"></a>
<p>From toxiclibs.org:</p>
<p><em>“toxiclibs is an independent, open source library collection for computational design tasks with Java &#x26; Processing developed by Karsten “toxi” Schmidt (thus far). The classes are purposefully kept fairly generic in order to maximize re-use in different contexts ranging from generative design, animation, interaction/interface design, data visualization to architecture and digital fabrication, use as teaching tool and more.”</em></p>
<p>In other words, we should thank our lucky stars for toxiclibs. We are only going to focus on a few examples related to Verlet physics, but toxiclibs includes a suite of other wonderful packages that help with audio, color, geometry, and more. In particular, if you are looking to work with form and fabrication in Processing, take a look at the geometry package. Demos can be found at Open Processing.</p>
<p>We should note that toxiclibs was designed specifically for use with Processing. This is great news. The trouble we had with making Box2D work in Processing (multiple coordinate systems, Box2D vs. JBox2D vs. Box2D-for-Processing) is not an issue here. toxiclibs is a library that you just download, stick in your libraries folder, and use. And the coordinate system that we’ll use for the physics engine is the coordinate system of Processing, so no translating back and forth. In addition, toxiclibs is not limited to a 2D world; all of the physics simulations and functions work in both two and three dimensions. So how do you decide which library you should use? Box2D or toxiclibs? If you fall into one of the following two categories, your decision is a bit easier:</p><a data-type="indexterm" data-primary="Box2D" data-secondary="toxiclibs vs."></a><a data-type="indexterm" data-primary="collisions" data-secondary="toxiclibs and"></a><a data-type="indexterm" data-primary="toxiclibs" data-secondary="Box2D vs."></a>
<p><strong>1. My project involves collisions. I have circles, squares, and other strangely shaped objects that knock each other around and bounce off each other.</strong></p>
<p>In this case, you are going to need Box2D. toxiclibs does not handle collisions.</p>
<p><strong>2. My project involves lots of particles flying around the screen. Sometimes they attract each other. Sometimes they repel each other. And sometimes they are connected with springs.</strong></p>
<p>In this case, toxiclibs is likely your best choice. It is simpler to use than Box2D and particularly well suited to connected systems of particles. toxiclibs is also very high performance, due to the speed of the Verlet integration algorithm (not to mention the fact that the program gets to ignore all of the collision geometry).</p>
<p>Here is a little chart that covers some of the features for each physics library.</p>
<h3 id="getting-toxiclibs">Getting toxiclibs</h3><a data-type="indexterm" data-primary="toxiclibs" data-secondary="downloading"></a>
<p>Everything you need to download and install toxiclibs can be found at: toxiclibs</p>
<p>When you download the library, you’ll notice that it comes with eight modules (i.e. sub-folders), each a library in its own right. For the examples in this chapter, you will only need “verletphysics” and “toxiclibscore”; however, I recommend you take a look at and consider using all of the modules!</p>
<p>Once you have the library installed to your Processing library folder, you are ready to start looking at the following examples.</p>
<h3 id="core-elements-of-verletphysics">Core Elements of VerletPhysics</h3><a data-type="indexterm" data-primary="VerletPhysics class (toxiclibs)" data-secondary="core elements of"></a>
<p>We spent a lot of time working through the core elements of a Box2D world: world, body, shape, joint. This gives us a head start on understanding toxiclibs, since it follows a similar structure.</p>
<h3 id="vectors-with-toxiclibs">Vectors with toxiclibs</h3><a data-type="indexterm" data-primary="Vec2D (toxiclibs type)"></a><a data-type="indexterm" data-primary="Vec3D (toxiclibs type)"></a>
<p>Here we go again. Remember all that time we spent learning the ins and outs of the <code>PVector</code> class? Then remember how when we got to Box2D, we had to translate all those concepts to a Box2D vector class: <code>Vec2</code>? Well, it’s time to do it again. toxiclibs also includes its own vector classes, one for two dimensions and one for three: <code>Vec2D</code> and <code>Vec3D</code>.</p>
<p>Again, toxiclibs vectors are the same conceptually, but we need to learn a bit of new syntax. You can find all of the documentation for these vector classes here:</p>
<p>Vec2DVec3D</p>
<p>And let’s just review some of the basic vector math operations with <code>PVector</code> translated to <code>Vec2D</code> (we’re sticking with 2D for simplicity’s sake).</p><a data-type="indexterm" data-primary="Vec2D (toxiclibs type)" data-secondary="math functions for"></a>
<h3 id="building-the-toxiclibs-physics-world">Building the toxiclibs physics world</h3><a data-type="indexterm" data-primary="toxiclibs" data-secondary="world" data-tertiary="building"></a>
<p>The first thing we need to do to create a toxiclibs physics world in our examples is import the library itself.</p>
<pre class="codesplit" data-code-language="javascript">// Importing the libraries
import toxi.physics2d.*;
import toxi.physics2d.behaviors.*;
import toxi.geom.*;</pre><a data-type="indexterm" data-primary="toxiclibs" data-secondary="VerletPhysics class"></a><a data-type="indexterm" data-primary="toxiclibs" data-secondary="VerletPhysics2D class"></a><a data-type="indexterm" data-primary="VerletPhysics class (toxiclibs)"></a><a data-type="indexterm" data-primary="VerletPhysics2D class (toxiclibs)"></a>
<p>Then we’ll need a reference to our physics world, a <code>VerletPhysics</code> or <code>VerletPhysics2D</code> object (depending on whether we are working in two or three dimensions). The examples in this chapter will operate in 2D only for simplicity, but they could easily be extended into 3D (and 3D versions are available with the chapter download).</p>
<pre class="codesplit" data-code-language="javascript">VerletPhysics2D physics;

void setup() {
  // Creating a toxiclibs Verlet physics world
  physics = new VerletPhysics2D();</pre>
<p>Once you have your <code>VerletPhysics</code> object, you can set some global properties for your world. For example, if you want it to have hard boundaries past which objects cannot travel, you can set its limits:</p>
<pre class="codesplit" data-code-language="javascript">  physics.setWorldBounds(new Rect(0,0,width,height));</pre><a data-type="indexterm" data-primary="gravity" data-secondary="GravityBehavior (toxiclibs)"></a><a data-type="indexterm" data-primary="GravityBehavior class (toxiclibs)"></a>
<p>In addition, you can add gravity to the physics world with a <code>GravityBehavior</code> object. A gravity behavior requires a vector—how strong and in what direction is the gravity?</p>
<pre class="codesplit" data-code-language="javascript">  physics.addBehavior(new GravityBehavior(new Vec2D(0, 0.5)));
}</pre><a data-type="indexterm" data-primary="update() function (toxiclibs)"></a>
<p>Finally, in order to calculate the physics of the world and move the objects in the world, we have to call <code>update()</code>. Typically this would happen once per frame in <code>draw()</code>.</p>
<pre class="codesplit" data-code-language="javascript">void draw() {
  //{!1} This is the same as Box2D’s “step()” function
  physics.update();
}</pre>
<h2 id="516-particles-and-springs-in-toxiclibs">5.16 Particles and Springs in toxiclibs</h2><a data-type="indexterm" data-primary="particles" data-secondary="toxiclibs implementation of"></a><a data-type="indexterm" data-primary="toxiclibs" data-secondary="particles" data-tertiary="implementing in"></a>
<p>In the Box2D examples, we saw how we can create our own class (called, say, <code>Particle</code>) and include a reference to a Box2D body.</p>
<pre class="codesplit" data-code-language="javascript">class Particle {
  Body body;</pre>
<p>This technique is somewhat redundant since Box2D itself keeps track of all of the bodies in its world. However, it allows us to manage which body is which (and therefore how each body is drawn) without having to rely on iterating through Box2D’s internal lists.</p><a data-type="indexterm" data-primary="particles" data-secondary="VerletParticle2D object (toxiclibs)"></a><a data-type="indexterm" data-primary="VerletParticle2D object (toxiclibs)"></a>
<p>Let’s look at how we might take the same approach with the class <code>VerletParticle2D</code> in toxiclibs. We want to make our own <code>Particle</code> class so that we can draw our particles a certain way and include any custom properties. We’d probably write our code as follows:</p>
<pre class="codesplit" data-code-language="javascript">class Particle {
  //{!1} The Particle has a reference to a VerletParticle.
  VerletParticle2D p;

  Particle(Vec2D pos) {
    //{!1} A VerletParticle needs an initial position (an x and y).
    p = new VerletParticle2D(pos);
  }

  void display() {
    fill(0, 150);
    stroke(0);
    //{!1} When it comes time to draw the Particle, we ask the
    // VerletParticle for its x and y coordinates.
    ellipse(p.x, p.y, 16, 16);
  }
}</pre>
<p>Looking at the above, we should first be thrilled to notice that drawing the particle is as simple as grabbing the <em>x</em> and <em>y</em> and using them. No awkward conversions between coordinate systems here since toxiclibs is designed to think in pixels. Second, you might notice that this <code>Particle</code> class’s sole purpose is to store a reference to a <code>VerletParticle2D</code> object. This hints at something. Remember our discussion of inheritance back in Chapter 4: Particle Systems? What is a <code>Particle</code> object other than an “augmented” <code>VerletParticle</code>? Why bother making a Verlet particle inside a particle when we could simply <code>extend VerletParticle</code>?</p>
<pre class="codesplit" data-code-language="javascript">class Particle extends VerletParticle2D {

  Particle(Vec2D loc) {
    //{!1} Calling super() so that the object is initialized properly
    super(loc);
  }

  //{!1} We want this to be just like a VerletParticle, only with a display() method.
  void display() {
    fill(175);
    stroke(0);
    //{!1} We’ve inherited x and y from VerletParticle!
    ellipse(x, y, 16, 16);
  }
}</pre>
<p>Remember our multi-step process with the Box2D examples? We had to ask the body for its position, then convert that position to pixels, then use that position in a drawing function. Now, because we have inherited everything from the <code>VerletParticle</code> class, our only step is to draw the shape at <code>x</code> and <code>y</code>!</p><a data-type="indexterm" data-primary="Vec2D (toxiclibs type)" data-secondary="VerletParticle2D class and"></a>
<p>Incidentally, it’s interesting to note that the <code>VerletParticle2D</code> class is a subclass of <code>Vec2D</code>. So in addition to inheriting everything from <code>VerletParticle2D</code>, our <code>Particle</code> class actually has all of the <code>Vec2D</code> functions available as well.</p>
<p>We can now create particles anywhere within our sketch.</p>
<pre class="codesplit" data-code-language="javascript">  Particle p1 = new Particle(new Vec2D(100, 20));
  Particle p2 = new Particle(new Vec2D(100, 180));</pre><a data-type="indexterm" data-primary="addParticle() function (toxiclibs)"></a><a data-type="indexterm" data-primary="particle systems" data-secondary="addParticle() function (toxiclibs)"></a>
<p>Just making a particle isn’t enough, however. We have to make sure we tell our physics world about them with the <code>addParticle()</code> function.</p>
<pre class="codesplit" data-code-language="javascript">  physics.addParticle(p1);
  physics.addParticle(p2);</pre>
<p>If you look at the toxiclibs documentation, you’ll see that the <code>addParticle()</code> expects a <code>VerletParticle2D</code> object.</p>
<p><code>addParticle(VerletParticle2D particle)</code></p>
<p>And how can we then pass into the function our own <code>Particle</code> object? Remember that other tenet of object-oriented programming—polymorphism? Here, because our <code>Particle</code> class <code>extends VerletParticle2D</code>, we can choose to treat our particle in two different ways—as a <code>Particle</code> or as a <code>VerletParticle2D</code>. This is an incredibly powerful feature of object-oriented programming. If we build our custom classes based on classes from toxiclibs, we can use our objects in conjunction with all of the functions toxiclibs has to offer.</p><a data-type="indexterm" data-primary="springs" data-secondary="toxiclibs and"></a><a data-type="indexterm" data-primary="toxiclibs" data-secondary="springs"></a>
<p>In addition to the <code>VerletParticle</code> class, toxiclibs has a set of classes that allow you to connect particles with spring forces. There are three types of springs in toxiclibs:</p><a data-type="indexterm" data-primary="springs" data-secondary="VerletConstrainedSpring class (toxiclibs)"></a><a data-type="indexterm" data-primary="springs" data-secondary="VerletMinDistanceSpring class (toxiclibs)"></a><a data-type="indexterm" data-primary="springs" data-secondary="VerletSpring class (toxiclibs)"></a><a data-type="indexterm" data-primary="VerletMinDistanceSpring class (toxiclibs)"></a><a data-type="indexterm" data-primary="VerletSpring class (toxiclibs)"></a>
<ul>
  <li><code>VerletSpring</code>: This class creates a springy connection between two particles in space. A spring’s properties can be configured in such a way as to create a stiff stick-like connection or a highly elastic stretchy connection. A particle can also be locked so that only one end of the spring can move.</li>
  <li><code>VerletConstrainedSpring</code>: A <code>VerletConstrainedSpring</code> object is a spring whose maximum distance can be limited. This can help the whole spring system achieve better stability.</li>
  <li><code>VerletMinDistanceSpring</code>: A <code>VerletMinDistanceSpring</code> object is a spring that only enforces its rest length if the current distance is less than its rest length. This is handy if you want to ensure objects are at least a certain distance from each other, but don’t care if the distance is bigger than the enforced minimum.</li>
</ul>
<p>The inheritance and polymorphism technique we employed in the previous section also proves to be useful when creating springs. A spring expects two particles when it is created. And again, because our <code>Particle</code> class <code>extends VerletParticle</code>, a <code>VerletSpring</code> object will accept our <code>Particle</code> objects passed into the constructor. Let’s take a look at some example code that assumes the existence of our two previous particles <code>p1</code> and <code>p2</code> and creates a connection between them with a given rest length and strength.</p>
<pre class="codesplit" data-code-language="javascript">//{!1} What is the rest length of the spring?
float len = 80;
//{!1} How strong is the spring?
float strength = 0.01;
VerletSpring2D spring=new VerletSpring2D(p1, p2, len, strength);</pre>
<p>Just as with particles, in order for the connection to actually be part of the physics world, we need to explicitly add it.</p>
<pre class="codesplit" data-code-language="javascript">physics.addSpring(spring);</pre>
<h2 id="517-putting-it-all-together-a-simple-interactive-spring">5.17 Putting It All Together: A Simple Interactive Spring</h2><a data-type="indexterm" data-primary="lock() function (toxiclibs)"></a><a data-type="indexterm" data-primary="springs" data-secondary="lock() function (toxiclibs)"></a>
<p>One thing we saw with Box2D is that the physics simulation broke down when we overrode it and manually set the position of a body. With toxiclibs, we don’t have this problem. If we want to move the position of a particle, we can simply set its <em>x</em> and <em>y</em> position manually. However, before we do so, it’s generally a good idea to call the <code>lock()</code> function.</p>
<p><code>lock()</code> is typically used to lock a particle in place and is identical to setting a Box2D body’s density to 0. However, here we are going to show how to lock a particle temporarily, move it, and then unlock it so that it continues to move according to the physics simulation. Let’s say you want to move a given particle whenever you click the mouse.</p>
<pre class="codesplit" data-code-language="javascript">  if (mousePressed) {
    //{!4} First lock the particle, then set the x and y, then unlock() it.
    p2.lock();
    p2.x = mouseX;
    p2.y = mouseY;
    p2.unlock();
  }</pre>
<p>And now we’re ready to put all of these elements together in a simple example that connects two particles with a spring. One particle is locked in place, and the other can be moved by dragging the mouse. Note that this example is virtually identical to Example 3.11.</p>
<div data-type="example">
  <h3 id="example-510-simple-spring-with-toxiclibs">Example 5.10: Simple Spring with toxiclibs</h3>
  <p>{p5 sketch link}</p>
  <figure>
    <img src="images/06_libraries/06_libraries_23.png" alt=" ">
    <figcaption> </figcaption>
  </figure>
</div>
<pre class="codesplit" data-code-language="javascript">import toxi.physics2d.*;
import toxi.physics2d.behaviors.*;
import toxi.geom.*;

VerletPhysics2D physics;
Particle p1;
Particle p2;

void setup() {
  size(640, 360);

  // Creating a physics world
  physics = new VerletPhysics2D();
  physics.addBehavior(new GravityBehavior2D(new Vec2D(0, 0.5)));
  physics.setWorldBounds(new Rect(0, 0, width, height));

  // Creating two Particles
  p1 = new Particle(new Vec2D(100, 20));
  p2 = new Particle(new Vec2D(100, 180));
  // Locking Particle 1 in place
  p1.lock();

  // Creating one Spring
  VerletSpring2D spring=new VerletSpring2D(p1,p2,80,0.01);

  //{!3} Must add everything to the world
  physics.addParticle(p1);
  physics.addParticle(p2);
  physics.addSpring(spring);
}

void draw() {
  //{!1} Must update the physics
  physics.update();

  background(255);

  //{!3} Drawing everything
  line(p1.x, p1.y, p2.x, p2.y);
  p1.display();
  p2.display();

  if (mousePressed) {
    //{!4} Moving a Particle according to the mouse
    p2.lock();
    p2.x = mouseX;
    p2.y = mouseY;
    p2.unlock();
  }
}

// How cute is our simple Particle class?!
class Particle extends VerletParticle2D {

  Particle(Vec2D loc) {
    super(loc);
  }

  void display() {
    fill(175);
    stroke(0);
    ellipse(x,y,16,16);
  }
}</pre>
<h2 id="518-connected-systems-part-i-string">5.18 Connected Systems, Part I: String</h2><a data-type="indexterm" data-primary="connected systems" data-secondary="strings"></a><a data-type="indexterm" data-primary="toxiclibs" data-secondary="connected systems"></a>
<p>The above example, two particles connected with a single spring, is the core building block for what toxiclibs’ physics is particularly well suited for: soft body simulations. For example, a string can be simulated by connecting a line of particles with springs. A blanket can be simulated by connecting a grid of particles with springs. And a cute, cuddly, squishy cartoon character can be simulated by a custom layout of particles connected with springs.</p>
<figure>
  <img src="images/06_libraries/06_libraries_24.png" alt="Figure 5.14">
  <figcaption>Figure 5.14</figcaption>
</figure>
<p>Let’s begin by simulating a “soft pendulum”—a bob hanging from a string, instead of a rigid arm like we had in Chapter 3, Example 10. Let’s use the "string" in Figure 5.14 above as our model.</p>
<p>First, we’ll need a list of particles (let’s use the same <code>Particle</code> class we built in the previous example).</p>
<pre class="codesplit" data-code-language="javascript">ArrayList&#x3C;Particle> particles = new ArrayList&#x3C;Particle>();</pre>
<p>Now, let’s say we want to have 20 particles, all spaced 10 pixels apart.</p>
<figure>
  <img src="images/06_libraries/06_libraries_25.png" alt="Figure 5.15">
  <figcaption>Figure 5.15</figcaption>
</figure>
<pre class="codesplit" data-code-language="javascript">float len = 10;
float numParticles = 20;</pre>
<p>We can loop from <code>i</code> equals 0 all the way up to 20, with each particle’s <em>y</em> position set to <code>i * 10</code> so that the first particle is at <em>(0,10)</em>, the second at <em>(0,20)</em>, the third at <em>(0,30)</em>, etc.</p>
<pre class="codesplit" data-code-language="javascript">for(int i=0; i &#x3C; numPoints; i++) {
  //{!1} Spacing them out along the x-axis
  Particle particle=new Particle(i*len, 10);
  //{!1} Add the particle to the physics world.
  physics.addParticle(particle);
  //{!1} Add the particle to our list.
  particles.add(particle);
}</pre>
<p>Even though it’s a bit redundant, we’re going to add the particle to both the toxiclibs physics world and to our own list. In case we eventually have multiple strings, this will allow us to know which particles are connected to which strings.</p>
<p>Now for the fun part: It’s time to connect all the particles. Particle 1 will be connected to particle 0, particle 2 to particle 1, 3 to 2, 4 to 3, etc.</p>
<figure>
  <img src="images/06_libraries/06_libraries_26.png" alt="Figure 5.16">
  <figcaption>Figure 5.16</figcaption>
</figure>
<p>In other words, particle <code>i</code> needs to be connected to particle <code>i-1</code> (except for when <code>i</code> equals zero).</p>
<pre class="codesplit" data-code-language="javascript">if (i != 0) {
  //{!1} First we need a reference to the previous particle.
  Particle previous = particles.get(i-1);

  //{!1} Then we make a spring connection between the particle and the previous particle with a rest length and strength (both floats).
  VerletSpring2D spring = new VerletSpring2D(particle, previous, len, strength);

  //{!1} We must not forget to add the spring to the physics world.
  physics.addSpring(spring);
}</pre><a data-type="indexterm" data-primary="strings" data-secondary="hanging from fixed points"></a>
<p>Now, what if we want the string to hang from a fixed point? We can lock one of the particles—the first, the last, the middle one, etc. Here’s how we would access the first particle (in the <code>ArrayList</code>) and lock it.</p>
<pre class="codesplit" data-code-language="javascript">Particle head=particles.get(0);
head.lock();</pre>
<p>And if we want to draw all the particles as being connected with a line, along with a circle for the last particle, we can use <code>beginShape()</code>, <code>endShape()</code>, and <code>vertex()</code>, accessing the particle positions from our <code>ArrayList</code>.</p>
<div data-type="example">
  <h3 id="example-511-soft-swinging-pendulum">Example 5.11: Soft swinging pendulum</h3>
  <p>{p5 sketch link}</p>
  <figure>
    <img src="images/06_libraries/06_libraries_27.png" alt=" ">
    <figcaption> </figcaption>
  </figure>
</div>
<pre class="codesplit" data-code-language="javascript">stroke(0);
noFill();
beginShape();
for (Particle p : particles) {
  //{!1} Each particle is one point in the line.
  vertex(p.x, p.y);
}
endShape();
Particle tail = particles.get(numPoints-1);
//{!1} This draws the last particle as a circle.
tail.display();</pre>
<p>The full code available with the chapter download also demonstrates how to drag the tail particle with the mouse.</p>
<div data-type="exercise">
  <h3 id="exercise-513-1">Exercise 5.13</h3>
  <p>Create a hanging cloth simulation using the technique above, but connect all the particles with a grid as demonstrated in the screenshot below.</p>
  <figure>
    <img src="images/06_libraries/06_libraries_28.png" alt=" ">
    <figcaption> </figcaption>
  </figure>
</div>
<h2 id="519-connected-systems-part-ii-force-directed-graph">5.19 Connected Systems, Part II: Force-Directed Graph</h2><a data-type="indexterm" data-primary="connected systems" data-secondary="force-directed graphs"></a><a data-type="indexterm" data-primary="force-directed graphs"></a><a data-type="indexterm" data-primary="toxiclibs" data-secondary="force-directed graphs"></a>
<p>Have you ever encountered the following scenario?</p>
<p>“I have a whole bunch of stuff I want to draw on the screen and I want all that stuff to be spaced out evenly in a nice, neat, organized manner. Otherwise I have trouble sleeping at night.”</p>
<p>This is not an uncommon problem in computational design. One solution is typically referred to as a “force-directed graph.” A force-directed graph is a visualization of elements—let’s call them “nodes”—in which the positions of those nodes are not manually assigned. Rather, the nodes arrange themselves according to a set of forces. While any forces can be used, a typical example involves spring forces. And so toxiclibs is perfect for this scenario.</p>
<figure>
  <img src="images/06_libraries/06_libraries_29.png" alt=" ">
  <figcaption> </figcaption>
</figure>
<figure>
  <img src="images/06_libraries/06_libraries_30.png" alt=" ">
  <figcaption> </figcaption>
</figure>
<figure>
  <img src="images/06_libraries/06_libraries_31.png" alt=" ">
  <figcaption> </figcaption>
</figure>
<p>How do we implement the above?</p>
<p>First, we’ll need a <code>Node</code> class. This is the easy part; it can <code>extend VerletParticle2D</code>. Really, this is just what we did before, only we’re calling it <code>Node</code> now instead of <code>Particle</code>.</p>
<pre class="codesplit" data-code-language="javascript">class Node extends VerletParticle2D {
  Node(Vec2D pos) {
    super(pos);
  }

  void display() {
    fill(0,150);
    stroke(0);
    ellipse(x,y,16,16);
  }
}</pre>
<p>Next we can write a class called <code>Cluster</code>, which will describe a list of nodes.</p>
<pre class="codesplit" data-code-language="javascript">class Cluster {

  ArrayList&#x3C;Node> nodes;

  //{!1} We’ll use this variable for the rest length between all the nodes.
  float diameter;

  Cluster(int n, float d, Vec2D center) {
    nodes = new ArrayList&#x3C;Node>();
    diameter = d;

    for (int i = 0; i &#x3C; n; i++) {
      //[offset-down] Here’s a funny little detail.  We’re going to have a problem
      // if all the Node objects start in exactly the same position.
      // So we add a random vector to the center position so that each
      // Node is slightly offset.
      nodes.add(new Node(center.add(Vec2D.randomVector())));



    }
  }</pre>
<p>Let’s assume we added a <code>display()</code> function to draw all the nodes in the cluster and created a <code>Cluster</code> object in <code>setup()</code> and displayed it in <code>draw()</code>. If we ran the sketch as is, nothing would happen. Why? Because we forgot the whole force-directed graph part! We need to connect every single node to every other node with a force. But what exactly do we mean by that? Let’s assume we have four <code>Node</code> objects: 0, 1, 2 and 3. Here are our connections:</p>
<p></p>
<p>Notice two important details about our connection list.</p>
<ul>
  <li><strong><em>No node is connected to itself.</em></strong> We don’t have 0 connected to 0 or 1 connected to 1.</li>
  <li><strong><em>We don’t need to repeat connections in reverse.</em></strong> In other words, if we’ve already said 0 is connected to 1, we don’t need to say 1 is connected to 0 because, well, it already is!</li>
</ul>
<p>So how do we write code to make these connections for <em>N</em> number of nodes?</p>
<p>Look at the left column. It reads: 000 11 2. So we know we need to access each node in the list from 0 to <em>N</em>-1.</p>
<pre class="codesplit" data-code-language="javascript">    for (int i = 0; i &#x3C; nodes.size()-1; i++) {
      VerletParticle2D ni = nodes.get(i);</pre>
<p>Now, we know we need to connect node 0 to nodes 1,2,3. For node 1: 2,3. For node 2: 3. So for every node i, we must loop from i+1 until the end of the list.</p>
<pre class="codesplit" data-code-language="javascript">      //{!1 .bold} Look how we start j at i + 1.
      for (int j = i+1; j &#x3C; nodes.size(); j++) {
        VerletParticle2D nj = nodes.get(j);</pre>
<p>With every two <code>Node</code><code>s</code> we find, all we have to do then is make a spring.</p>
<pre class="codesplit" data-code-language="javascript">        //{!1} The Spring connects Nodes “ni” and “nj”.
        physics.addSpring(new VerletSpring2D(ni,nj,diameter,0.01));
      }
    }</pre>
<p>Assuming those connections are made in the <code>Cluster</code> constructor, we can now create a cluster in our main tab and see the results!</p>
<div data-type="example">
  <h3 id="example-512-cluster">Example 5.12: Cluster</h3>
  <p>{p5 sketch link}</p>
  <figure>
    <img src="images/06_libraries/06_libraries_32.png" alt=" ">
    <figcaption> </figcaption>
  </figure>
</div>
<pre class="codesplit" data-code-language="javascript">import toxi.geom.*;
import toxi.physics2d.*;

VerletPhysics2D physics;
Cluster cluster;

void setup() {
  size(300,300);
  physics=new VerletPhysics2D();
  //{!1} Make a cluster.
  cluster = new Cluster(8, 100, new Vec2D(width/2, height/2));
}

void draw() {
  physics.update();
  background(255);
  //{!1} Draw the cluster.
  cluster.display();
}</pre>
<div data-type="exercise">
  <h3 id="exercise-514-1">Exercise 5.14</h3>
  <p>Use the <code>Cluster</code> structure as a skeleton for a cute, cuddly, squishy creature (à la “Nokia Friends”). Add gravity and also allow the creature to be dragged with the mouse.</p>
</div>
<div data-type="exercise">
  <h3 id="exercise-515-1">Exercise 5.15</h3>
  <p>Expand the force-directed graph to have more than one <code>Cluster</code> object. Use a <code>VerletMinDistanceSpring2D</code> object to connect cluster to cluster.</p>
  <figure>
    <img src="images/06_libraries/06_libraries_33.png" alt=" ">
    <figcaption> </figcaption>
  </figure>
</div>
<h2 id="520-attraction-and-repulsion-behaviors">5.20 Attraction and Repulsion Behaviors</h2><a data-type="indexterm" data-primary="addForce() function (toxiclibs)"></a><a data-type="indexterm" data-primary="toxiclibs" data-secondary="attraction" data-tertiary="repulsion behaviors and"></a>
<p>When we looked at adding an attraction force to Box2D, we found that the Box2D <code>Body</code> class included an <code>applyForce()</code> function. All we needed to do was calculate the attraction force (Force = G * mass1 * mass2 / distance squared) as a vector and apply it to the body. toxiclibs <code>VerletParticle</code> class also includes a function called <code>addForce()</code> that we can use to apply any calculated force to a particle.</p><a data-type="indexterm" data-primary="AttractionBehavior class (toxiclibs)"></a><a data-type="indexterm" data-primary="toxiclibs" data-secondary="AttractionBehavior class"></a>
<p>However, toxiclibs also takes this idea one step further by allowing us to attach some common forces (let’s call them “behaviors”) to particles, calculating them and applying them for us! For example, if we attach an <code>AttractionBehavior</code> object to a particle, then all other particles in the physics world will be attracted to that particle.</p>
<p>Let’s say we have a <code>Particle</code> class (that <code>extends VerletParticle</code>).</p>
<pre class="codesplit" data-code-language="javascript">Particle p = new Particle(new Vec2D(200, 200));</pre>
<p>Once we’ve made a <code>Particle</code> object, we can create an <code>AttractionBehavior</code> object associated with that particle.</p>
<pre class="codesplit" data-code-language="javascript">float distance = 20;
float strength = 0.1;
AttractionBehavior behavior = new AttractionBehavior(p, distance, strength);</pre>
<p>Notice how the behavior is created with two parameters—<code>distance</code> and <code>strength</code>. The distance specifies the range within which the behavior will be applied. For example, in the above scenario, only other particles within twenty pixels will feel the attraction force. The strength, of course, specifies how strong the force is.</p>
<p>Finally, in order for the force to be activated, the behavior needs to be added to the physics world.</p>
<pre class="codesplit" data-code-language="javascript">physics.addBehavior(behavior);</pre>
<p>This means everything that lives in the physics simulation will always be attracted to that particle, as long as it is within the distance threshold.</p>
<p>Even though toxiclibs does not handle collisions, you can create a collision-like effect by adding a repulsive behavior to each and every particle (so that every particle repels every other particle). Let’s look at how we might modify our <code>Particle</code> class to do this.</p>
<pre class="codesplit" data-code-language="javascript">class Particle extends VerletParticle2D {

  //{!1} Add a radius to every Particle.
  float r;

  Particle (Vec2D loc) {
    super(loc);
    r = 4;
    //[offset-down] Every time a Particle is made, an AttractionBehavior is
    // generated and added to the physics world.
    // Note that when the strength
    // is negative, it’s a repulsive force!
    physics.addBehavior(new AttractionBehavior(this, r*4, -1));
  }

  void display () {
    fill (255);
    stroke (255);
    ellipse (x, y, r*2, r*2);
  }
}</pre>
<p>We could now recreate our attraction example by having a single <code>Attractor</code> object that exerts an attraction behavior over the entire window.</p>
<div data-type="example">
  <h3 id="example-513-attractionrepulsion">Example 5.13: Attraction/Repulsion</h3>
  <p>{p5 sketch link}</p>
  <figure>
    <img src="images/06_libraries/06_libraries_34.png" alt=" ">
    <figcaption> </figcaption>
  </figure>
</div>
<pre class="codesplit" data-code-language="javascript">class Attractor extends VerletParticle2D {

  float r;

  Attractor (Vec2D loc) {
    super (loc);
    r = 24;
    //[offset-down] The AttractionBehavior “distance” equals
    // the width so that it covers the entire window.
    physics.addBehavior(new AttractionBehavior(this, width, 0.1));
  }

  void display () {
    fill(0);
    ellipse (x, y, r*2, r*2);
  }
}</pre>
<div data-type="exercise">
  <h3 id="exercise-516-1">Exercise 5.16</h3>
  <p>Create an object that both attracts and repels. What if it attracts any particle that is far away but repels those particles at a short distance?</p>
</div>
<div data-type="exercise">
  <h3 id="exercise-517-1">Exercise 5.17</h3>
  <p>Use <code>AttractionBehavior</code> in conjunction with spring forces.</p>
</div>
<div data-type="project">
  <h3 id="the-ecosystem-project-5">The Ecosystem Project</h3>
  <p>Step 5 Exercise:</p>
  <p>Take your system of creatures from Step 4 and use a physics engine to drive their motion and behaviors. Some possibilities:</p>
  <ul>
    <li>Use Box2D to allow collisions between creatures. Consider triggering events when creatures collide.</li>
    <li>Use Box2D to augment the design of your creatures. Build a skeleton with distance joints or make appendages with revolute joints.</li>
    <li>Use toxiclibs to augment the design of your creature. Use a chain of toxiclibs particles for tentacles or a mesh of springs as a skeleton.</li>
    <li>Use toxiclibs to add attraction and repulsion behaviors to your creatures.</li>
    <li>Use spring (or joint) connections between objects to control their interactions. Create and delete these springs on the fly. Consider making these connections visible or invisible to the viewer.</li>
  </ul>
</div>
<p>
  let vertices = [];
  vertices[4] = Vector.create(-15, 25);
  vertices[3] = Vector.create(-5, 20);
  vertices[2] = Vector.create(15, 0);
  vertices[1] = Vector.create(20, -15);
  vertices[0] = Vector.create(-10, -10);
</p>
<p>
  let vertices = [];
  vertices[4] = Vector.create(-15, 25);
  vertices[3] = Vector.create(-5, 20);
  vertices[2] = Vector.create(15, 0);
  vertices[1] = Vector.create(20, -15);
  vertices[0] = Vector.create(-10, -10);
</p>
</section>